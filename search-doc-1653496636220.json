[{"title":"Cargo.toml","type":0,"sectionRef":"#","url":"basics/cargo-toml","content":"Cargo.toml TODO go through a typical Cargo.toml and explain what the dependencies mean","keywords":""},{"title":"Contract Template","type":0,"sectionRef":"#","url":"basics/contract-template","content":"Contract Template Change into your working directory and run: cargo contract new foobar This will create a new project folder named foobar. cd foobar/ In the lib.rs file you find initial scaffolded code, which you can use as a starting point. Quickly check that it compiles and the trivial tests pass with: cargo +nightly test Also check that you can build the Wasm file by running: cargo +nightly contract build If everything looks good, then we are ready to start programming!","keywords":""},{"title":"Cross-Contract Calling","type":0,"sectionRef":"#","url":"basics/cross-contract-calling","content":"","keywords":""},{"title":"How it Works​","type":1,"pageTitle":"Cross-Contract Calling","url":"basics/cross-contract-calling#how-it-works","content":"In order to deploy the delegator smart contract we first have to manually put the code of the other contract, receive its code hash from the signalled event and put their code hash into our calling smart contract. The calling contract looks like this: use other_contract::OtherContract; //--snip-- #[ink(storage)] struct MyContract { /// The other contract. other_contract: OtherContract, } impl MyContract { /// Instantiate `MyContract with the given /// sub-contract codes and some initial value. #[ink(constructor)] pub fn new( other_contract_code_hash: Hash, ) -&gt; Self { let other_contract = OtherContract::new(1337) .endowment(total_balance / 4) .code_hash(other_contract_code_hash) .instantiate() .expect(&quot;failed at instantiating the `OtherContract` contract&quot;); Self { other_contract } } /// Calls the other contract. #[ink(message)] pub fn call_other_contract(&amp;self) -&gt; i32 { self.other_contract.get_value() } } //--snip--  It's Cargo.toml contains other_contract = { path = &quot;other_contract&quot;, default-features = false, features = [&quot;ink-as-dependency&quot;] }  The other_contract/Cargo.toml contains this: [features] ink-as-dependency = []  Tells the ink! code generator to always or nevercompile the smart contract as if it was used as a dependency of another ink! smart contract. The other_contract/lib.rs: #[ink::contract] pub mod other_contract { /// Storage for the other contract. #[ink(storage)] pub struct OtherContract { value: i32, } impl OtherContract { /// Initializes the contract. #[ink(constructor)] pub fn new(value: i32) -&gt; Self { Self { value } } /// Returns the current state. #[ink(message)] pub fn get_value(&amp;self) -&gt; i32 { self.value } } }  "},{"title":"Contract Testing","type":0,"sectionRef":"#","url":"basics/contract-testing","content":"","keywords":""},{"title":"Unit Tests​","type":1,"pageTitle":"Contract Testing","url":"basics/contract-testing#unit-tests","content":"Testing contracts off-chain is done by cargo test and users can simply use the standard routines of creating unit test modules within the ink! project: #[cfg(test)] mod tests { use super::*; #[test] fn my_test() { ... } }  Test instances of contracts can be created with something like: let contract = MyContract::my_constructor(a, b);  Messages can simply be called on the returned instance as if MyContract::my_constructor returns aSelf instance. See the flipper example. "},{"title":"Off-chain Testing​","type":1,"pageTitle":"Contract Testing","url":"basics/contract-testing#off-chain-testing","content":"ink! smart contracts can compile in several different modes. There are two main compilation models using either on-chain mode: no_std + WebAssembly as targetoff-chain mode: std We generally use the on-chain mode for actual smart contract deployment whereas we use the off-chain mode for smart contract testing using the off-chain environment provided by the ink_env crate. The #[ink::test] proc. macro enables more elaborate off-chain testing. If you annotate a test with this attribute it will be executed in a simulated environment, similar to as it would be run on-chain. You then have fine-grained control over how a contract is called; for example you can influence the block advancement, the value transferred to it, by which account it is called, which storage it is run with, etc.. See the examples/erc20 contract on how to utilize those or the documentation for details. At the moment there are some known limitations to our off-chain environment and we are working on making it behave as close to the real chain environment as possible. Defines a unit test that makes use of ink!'s off-chain testing capabilities. If your unit test does not require the existence of an off-chain environment it is fine to not use this macro since it bears some overhead with the test. Note that this macro is not required to run unit tests that require ink!'s off-chain testing capabilities but merely improves code readability. "},{"title":"How do you find out if your test requires the off-chain environment?​","type":1,"pageTitle":"Contract Testing","url":"basics/contract-testing#how-do-you-find-out-if-your-test-requires-the-off-chain-environment","content":"Normally if the test recursively uses or invokes some contract methods that call a method defined in self.env() or Self::env(). An examples is the following: let caller: AccountId = self.env().caller();  "},{"title":"Example​","type":1,"pageTitle":"Contract Testing","url":"basics/contract-testing#example","content":"use ink_lang as ink; #[cfg(test)] mod tests { // Conventional unit test that works with assertions. #[ink::test] fn test1() { // test code comes here as usual } // Conventional unit test that returns some Result. // The test code can make use of operator-`?`. #[ink::test] fn test2() -&gt; Result&lt;(), ink_env::Error&gt; { // test code that returns a Rust Result type } }  "},{"title":"On-chain Testing​","type":1,"pageTitle":"Contract Testing","url":"basics/contract-testing#on-chain-testing","content":"The easiest way to do on-chain testing is torun a local substrate node, deploy your contract there and interact with it. use ink_lang as ink; #[ink::contract] mod greeter { #[ink(storage)] pub struct Greeter; impl Greeter { #[ink(constructor)] pub fn new() -&gt; Self { let caller = Self::env().caller(); let message = format!(&quot;thanks for instantiation {:?}&quot;, caller); ink_env::debug_println(&amp;message); Greeter {} } #[ink(message, payable)] pub fn fund(&amp;mut self) { let caller = self.env().caller(); let value = self.env().transferred_balance(); let message = format!(&quot;thanks for the funding of {:?} from {:?}&quot;, value, caller); ink_env::debug_println(&amp;message); } } }  "},{"title":"Environment Functions","type":0,"sectionRef":"#","url":"basics/environment-functions","content":"Environment Functions ink! exposes a number of handy environment functions. A full overview is found here. In an #[ink(constructor)] use Self::env() to access those, in an #[ink(message)] use self.env(). So e.g. Self::env().caller() or self.env().caller(). Some handy functions include: caller(): Returns the address of the caller of the executed contract.account_id(): Returns the account ID of the executed contract.balance(): Returns the balance of the executed contract.block_number(): Returns the current block number.random(): Returns a random hash seed.emit_event(…): Emits an event with the given event data.transfer(…): Transfers value from the contract to the destination account ID.hash_bytes(…): Conducts the crypto hash of the given input and stores the result in output.…and many more.","keywords":""},{"title":"Mutating Storage Values","type":0,"sectionRef":"#","url":"basics/mutating-values","content":"","keywords":""},{"title":"Mutable and Immutable Functions​","type":1,"pageTitle":"Mutating Storage Values","url":"basics/mutating-values#mutable-and-immutable-functions","content":"You may have noticed that the function template included self as the first parameter of the contract functions. It is through self that you gain access to all your contract functions and storage items. If you are simply reading from the contract storage, you only need to pass &amp;self. But if you want to modify storage items, you will need to explicitly mark it as mutable,&amp;mut self. impl MyContract { #[ink(message)] pub fn my_getter(&amp;self) -&gt; u32 { self.my_number } #[ink(message)] pub fn my_setter(&amp;mut self, new_value: u32) { self.my_number = new_value; } }  "},{"title":"Events","type":0,"sectionRef":"#","url":"basics/events","content":"","keywords":""},{"title":"Event Definition​","type":1,"pageTitle":"Events","url":"basics/events#event-definition","content":"This is how an event definition looks: #[ink(event)] pub struct Transferred { #[ink(topic)] from: Option&lt;AccountId&gt;, #[ink(topic)] to: Option&lt;AccountId&gt;, amount: Balance }  Add the #[ink(topic)] attribute tag to each item in your event that you want to have indexed. A good rule of thumb is to ask yourself if somebody might want to search for this topic. For this reason the amount in the exemplary event above was not made indexable ‒ there will most probably be a lot of different events with differing amounts each. The signature of the event is by default one of the topics of the event, except if you annotate the event with #[ink(anonymous)]. See here for details on this attribute. "},{"title":"Emitting Events in a Constructor​","type":1,"pageTitle":"Events","url":"basics/events#emitting-events-in-a-constructor","content":"In a constructor events are emitted via Self::env().emit_event(). See this example: #[ink(constructor)] pub fn new(initial_value: Balance) -&gt; Self { let caller = Self::env().caller(); let mut balances = HashMap::new(); balances.insert(caller, initial_supply); Self::env().emit_event(Transferred { from: None, to: Some(caller), amount: initial_supply }); Self { total_supply: initial_supply, balances } }  "},{"title":"Emitting Events from Messages​","type":1,"pageTitle":"Events","url":"basics/events#emitting-events-from-messages","content":"In a message events are emitted via self.env().emit_event(): #[ink(message)] pub fn transfer(&amp;mut self, to: AccountId, amount: Balance) -&gt; Result { let from = self.env().caller(); // implementation hidden self.env().emit_event(Transferred { from: Some(from), to: Some(to), amount }); Ok(()) }  "},{"title":"Reading Values from Storage","type":0,"sectionRef":"#","url":"basics/reading-values","content":"","keywords":""},{"title":"Contract Functions​","type":1,"pageTitle":"Reading Values from Storage","url":"basics/reading-values#contract-functions","content":"As you can see in the contract template, all of your contract functions are part of your contract module. impl MyContract { // Public and Private functions can go here }  "},{"title":"Public and Private Functions​","type":1,"pageTitle":"Reading Values from Storage","url":"basics/reading-values#public-and-private-functions","content":"In Rust, you can make as many implementations as you want. As a stylistic choice, we recommend breaking up your implementation definitions for your private and public functions: impl MyContract { /// Public function #[ink(message)] pub fn my_public_function(&amp;self) { /* --snip-- */ } /// Private function fn my_private_function(&amp;self) { /* --snip-- */ } /* --snip-- */ }  You can also choose to split things up however is most clear for your project. Note that all public functions must use the #[ink(message)] attribute. "},{"title":"Getting a Value​","type":1,"pageTitle":"Reading Values from Storage","url":"basics/reading-values#getting-a-value","content":"We already showed you how to initialize a storage value in the chapter Storing Values. Getting the value is just as simple: impl MyContract { #[ink(message)] pub fn my_getter(&amp;self) -&gt; u32 { self.number } }  In Rust, if the last expression in a function does not have a semicolon, then it will be the return value. "},{"title":"Storing Values","type":0,"sectionRef":"#","url":"basics/storing-values","content":"","keywords":""},{"title":"Supported Types​","type":1,"pageTitle":"Storing Values","url":"basics/storing-values#supported-types","content":"Substrate contracts may store types that are encodable and decodable withParity Codec which includes most Rust common data types such as bool, u{8,16,32,64,128}, i{8,16,32,64,128}, String, tuples, and arrays. ink! provides Substrate specific types like AccountId, Balance, and Hash to smart contracts as if they were primitive types. ink! also provides a Mapping storage type. You can read more about it here. Here is an example of how you would store an AccountId and Balance: // We are importing the default ink! types use ink_lang as ink; #[ink::contract] mod MyContract { // Our struct will use those default ink! types #[ink(storage)] pub struct MyContract { // Store some AccountId my_account: AccountId, // Store some Balance my_balance: Balance, } /* --snip-- */ }  "},{"title":"Initializing Storage in Constructors​","type":1,"pageTitle":"Storing Values","url":"basics/storing-values#initializing-storage-in-constructors","content":"Constructors are how values get initialized. Every ink! smart contract must have a constructor which is run once when a contract is created. ink! smart contracts can have multiple constructors: Note that if you have a contract whose storage contains Mapping's you will need to useink_lang::utils::initialize_contract in your constructor. See theMapping documentation for more details. use ink_lang as ink; #[ink::contract] mod mycontract { #[ink(storage)] pub struct MyContract { number: u32, } impl MyContract { /// Constructor that initializes the `u32` value to the given `init_value`. #[ink(constructor)] pub fn new(init_value: u32) -&gt; Self { Self { number: init_value, } } /// Constructor that initializes the `u32` value to the `u32` default. #[ink(constructor)] pub fn default() -&gt; Self { Self { number: Default::default(), } } /* --snip-- */ } }  "},{"title":"Overview","type":0,"sectionRef":"#","url":"cargo-contract-cli","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Overview","url":"cargo-contract-cli#installation","content":"As a pre-requisite for the tool you need to install the binaryen package, which is used to optimize the WebAssembly bytecode of the contract. Many package managers have it available nowadays ‒ e.g. it's a package for Debian/Ubuntu,Homebrew and Arch Linux. After you've installed the package execute: cargo install cargo-contract --force --locked  Use the --force to ensure you are updated to the most recent cargo-contract version. You can then use cargo contract --help to start exploring the commands made available to you. "},{"title":"Usage​","type":1,"pageTitle":"Overview","url":"cargo-contract-cli#usage","content":"In order to initialize a new ink! project you can use: cargo contract new flipper  This will create a folder flipper in your work directory. The folder contains a scaffold Cargo.toml and a lib.rs, which both contain the necessary building blocks for using ink!. The lib.rs contains our hello world contract ‒ the Flipper, which we explain in the next section. In order to build the contract just execute these commands in the flipper folder: cargo contract build  As a result you'll get the file target/flipper.contract. It's a JSON which bundles the contract's metadata and its Wasm blob. This file needs to be used when deploying the contract. You additionally get the individual target/flipper.wasm and target/metadata.json in the folder as well. "},{"title":"Call a Contract","type":0,"sectionRef":"#","url":"cargo-contract-cli/call","content":"Call a Contract TODO","keywords":""},{"title":"Deploy a Contract","type":0,"sectionRef":"#","url":"cargo-contract-cli/deploy","content":"Deploy a Contract TODO","keywords":""},{"title":"Instantiate a Contract","type":0,"sectionRef":"#","url":"cargo-contract-cli/instantiate","content":"Instantiate a Contract TODO I am trying to deploy and instantiate a contract using a custom-built cargo-contract with the extrinsics feature. The 'deploy' and 'instantiate' commands require a &quot;secret key uri&quot; and &quot;secret key password&quot; that I don't know how to find for my canvas devnet. Can somebody help me understand what these are and how to obtain them? You probably just need to the key for some account with enough funds to deploy and instantiate the contract...I don't think the key is specific to the node in any way If you're running the Canvas node in dev mode, these are the accounts that are pre-funded https://github.com/paritytech/canvas-node/blob/master/node/src/chain_spec.rs#L76People typically use Alice...her information is here https://docs.substrate.io/v3/tools/subkey/#well-known-keys I guess you'd just leave the password blank So the secret key URI will be bottom drive obey lake curtain smoke basket hold race lonely fit walk//Alice I think","keywords":""},{"title":"Trait Definitions","type":0,"sectionRef":"#","url":"basics/trait-definitions","content":"","keywords":""},{"title":"Example​","type":1,"pageTitle":"Trait Definitions","url":"basics/trait-definitions#example","content":"Defined in the base_erc20.rs module. use ink_lang as ink; #[ink::trait_definition] pub trait BaseErc20 { /// Creates a new ERC-20 contract and initializes it with the initial supply for the instantiator. #[ink(constructor)] fn new(initial_supply: Balance) -&gt; Self; /// Returns the total supply. #[ink(message)] fn total_supply(&amp;self) -&gt; Balance; /// Transfers `amount` from caller to `to`. #[ink(message, payable)] fn transfer(&amp;mut self, to: AccountId, amount: Balance); }  An ink! smart contract definition can then implement this trait definition as follows: use ink_lang as ink; #[ink::contract] mod erc20 { use base_erc20::BaseErc20; #[ink(storage)] pub struct Erc20 { total_supply: Balance, // more fields ... } impl BaseErc20 for Erc20 { #[ink(constructor)] fn new(initial_supply: Balance) -&gt; Self { // implementation ... } #[ink(message)] fn total_supply(&amp;self) -&gt; Balance { // implementation ... } #[ink(message, payable)] fn transfer(&amp;mut self, to: AccountId, amount: Balance) { // implementation ... } } }  Calling the above Erc20 explicitely through its trait implementation can be done just as if it was normal Rust code: // --- Instantiating the ERC-20 contract: // let mut erc20 = &lt;Erc20 as BaseErc20&gt;::new(1000); // --- Is just the same as: use base_erc20::BaseErc20; let mut erc20 = Erc20::new(1000); // --- Retrieving the total supply: // assert_eq!(&lt;Erc20 as BaseErc20&gt;::total_supply(&amp;erc20), 1000); // --- Is just the same as: use base_erc20::BaseErc20; assert_eq!(erc20.total_supply(), 1000);  There are still many limitations to ink! trait definitions and trait implementations. For example it is not possible to define associated constants or types or have default implemented methods. These limitations exist because of technical intricacies, however, please expect that many of those will be tackled in future ink! releases. Marks trait definitions to ink! as special ink! trait definitions. There are some restrictions that apply to ink! trait definitions that this macro checks. Also ink! trait definitions are required to have specialized structure so that the main #[ink::contract] macro can properly generate code for its implementations. Example: Definition use ink_lang as ink; type Balance = &lt;ink_env::DefaultEnvironment as ink_env::Environment&gt;::Balance; #[ink::trait_definition] pub trait Erc20 { /// Constructs a new ERC-20 compliant smart contract using the initial supply. #[ink(constructor)] fn new(initial_supply: Balance) -&gt; Self; /// Returns the total supply of the ERC-20 smart contract. #[ink(message)] fn total_supply(&amp;self) -&gt; Balance; // etc. }  Example: Implementation Given the above trait definition you can implement it as shown below: use ink_lang as ink; #[ink::contract] mod base_erc20 { /// We somehow cannot put the trait in the doc-test crate root due to bugs. #[ink_lang::trait_definition] pub trait Erc20 { /// Constructs a new ERC-20 compliant smart contract using the initial supply. #[ink(constructor)] fn new(initial_supply: Balance) -&gt; Self; /// Returns the total supply of the ERC-20 smart contract. #[ink(message)] fn total_supply(&amp;self) -&gt; Balance; } #[ink(storage)] pub struct BaseErc20 { total_supply: Balance, // etc .. } impl Erc20 for BaseErc20 { #[ink(constructor)] fn new(initial_supply: Balance) -&gt; Self { Self { total_supply: initial_supply } } /// Returns the total supply of the ERC-20 smart contract. #[ink(message)] fn total_supply(&amp;self) -&gt; Balance { self.total_supply } // etc .. } }  "},{"title":"Custom Data Structures","type":0,"sectionRef":"#","url":"datastructures/custom-datastructure","content":"Custom Data Structures While the ink_storage crate provides tons of useful utilities and data structures to organize and manipulate the contract's storage contract authors are not limited by its capabilities. By implementing the core SpreadLayout/PackedLayout traits (and the StorageLayout trait for supporting the metadata generated for the .contract bundle) users are able to define their very own custom storage data structures with their own set of requirement and features that work along the ink_storage data structures as long as they fulfill the mere requirements stated by those two traits. A basic example of a custom struct is shown below: struct Inner { value: bool } #[ink(storage)] pub struct MyContract { inner: Inner } Compiling the above will result in errors. While having an inner struct which holds only a boolean might not be the best idea, it serves well to illustrate how to implement the trait: impl SpreadLayout for Inner { const FOOTPRINT: u64 = 1; fn pull_spread(ptr: &amp;mut KeyPtr) -&gt; Self { Self { value: SpreadLayout::pull_spread(ptr), } } fn push_spread(&amp;self, ptr: &amp;mut KeyPtr) { SpreadLayout::push_spread(&amp;self.value, ptr); } fn clear_spread(&amp;self, ptr: &amp;mut KeyPtr) { SpreadLayout::clear_spread(&amp;self.value, ptr); } } You can check what each method does in the trait's docs. Check how some data structures are implemented, such as Mapping.","keywords":""},{"title":"Overview","type":0,"sectionRef":"#","url":"datastructures/overview","content":"","keywords":""},{"title":"Eager Loading​","type":1,"pageTitle":"Overview","url":"datastructures/overview#eager-loading","content":"When executing a contract, all the fields of the #[ink(storage)] struct will be pulled from storage, regardless of whether or not they are used during the message execution. Smart contract authors should be aware of this behaviour since it could potentially affect their contract performance. For example, consider the following storage struct: #[ink(storage)] pub struct EagerLoading { a: i32, b: ink_prelude::vec::Vec&lt;i32&gt;, } impl EagerLoading { #[ink(message)] pub fn read_a(&amp;self) { let a = self.a; } }  In EagerLoading::read_a() we only read the a storage item. However, the b storage item will still be loaded from storage. As a reminder, this means accessing the underlying database and SCALE decoding the value. This can incur high costs, especially as the number of elements in b grows. "},{"title":"Spread Storage Layout","type":0,"sectionRef":"#","url":"datastructures/spread-storage-layout","content":"","keywords":""},{"title":"Storage Organization​","type":1,"pageTitle":"Spread Storage Layout","url":"datastructures/spread-storage-layout#storage-organization","content":"The following schema depicts the storage which is exposed to ink! by the contracts pallet:  ink!'s storage operates by storing and loading entries into and from a single storage cell. At the moment there is no way to customize this behaviour. Depending on the data we're dealing with, this can end up being good or bad. For example, if we have a somewhat small ink_prelude::vec::Vec loading all the elements at the same time can be advantegous - especially if we expect our message to interact with most of them in a single call. On the other hand, this can be problematic if we're loading a large Vec and only operating on a few elements. "},{"title":"Spreading​","type":1,"pageTitle":"Spread Storage Layout","url":"datastructures/spread-storage-layout#spreading","content":"ink! spreads information to as many cells as possible. For example if you have the following #[ink(storage)] struct every field will live in its own single storage cell. Note that for b all 32 bytes will share the same cell! #[ink(storage)] pub struct Spread { a: i32, b: [u8; 32], }  The following schema depicts the storage layout for a vector with three elements, persisted to storage in a spread layout.  "},{"title":"Working with Mapping","type":0,"sectionRef":"#","url":"datastructures/mapping","content":"","keywords":""},{"title":"Initializing a Mapping​","type":1,"pageTitle":"Working with Mapping","url":"datastructures/mapping#initializing-a-mapping","content":"In order to correctly initialize a Mapping we need two things: An implementation of the SpreadAllocate trait on our storage structThe ink_lang::utils::initalize_contract initializer Not initializing storage before you use it is a common mistake that can break your smart contract. If you do not initialize your Mapping's correctly you may end up with different Mapping's operating on the same set of storage entries 😱.  #![cfg_attr(not(feature = &quot;std&quot;), no_std)] use ink_lang as ink; #[ink::contract] mod mycontract { use ink_storage::traits::SpreadAllocate; #[ink(storage)] #[derive(SpreadAllocate)] pub struct MyContract { // Store a mapping from AccountIds to a u32 map: ink_storage::Mapping&lt;AccountId, u32&gt;, } impl MyContract { #[ink(constructor)] pub fn new(count: u32) -&gt; Self { // This call is required in order to correctly initialize the // `Mapping`s of our contract. ink_lang::utils::initialize_contract(|contract: &amp;mut Self| { let caller = Self::env().caller(); contract.map.insert(&amp;caller, &amp;count); }) } #[ink(constructor)] pub fn default() -&gt; Self { // Even though we're not explicitly initializing the `Mapping`, // we still need to call this ink_lang::utils::initialize_contract(|_| {}) } // Grab the number at the caller's AccountID, if it exists #[ink(message)] pub fn get(&amp;self) -&gt; u32 { let caller = Self::env().caller(); self.map.get(&amp;caller).unwrap_or_default() } } }  "},{"title":"Overview","type":0,"sectionRef":"#","url":"examples","content":"Overview In our examples folder you find a number of examples written in ink!. Some of the most interesting ones: delegator ‒ Implements cross-contract calling.trait-erc20 ‒ Defines a trait for Erc20 contracts and implements it.erc721 ‒ An exemplary implementation of Erc721 NFT tokens.dns ‒ A simple DomainNameService smart contract.…and more, just rummage through the folder 🙃. To build a single example navigate to the root of the example and run: cargo contract build As a result you'll get a file target/flipper.wasm file, a metadata.json file and a &lt;contract-name&gt;.contract file in the target/ folder of your contract. The .contract file combines the Wasm and metadata into one file and needs to be used when deploying the contract. For further information, please have a look at the Deploy your Contract section or our smart contracts workshop.","keywords":""},{"title":"Compile Your Contract","type":0,"sectionRef":"#","url":"getting-started/building-your-contract","content":"Compile Your Contract Run the following command in your flipper directory to compile your smart contract: cargo +nightly contract build This command will build the following for your contract: a Wasm binary, a metadata file (which contains the contract's ABI) and a .contract file which bundles both. This .contract file can be used to deploy your contract to a chain. If all goes well, you should see a target folder which contains these files: target └─ ink └─ flipper.contract └─ flipper.wasm └─ metadata.json Let's take a look at the structure of the metadata.json: { &quot;metadataVersion&quot;: &quot;0.1.0&quot;, &quot;source&quot;: {...}, &quot;contracts&quot;: {...}, &quot;spec&quot;: { &quot;constructors&quot;: [...], &quot;docs&quot;: [], &quot;events&quot;: [], &quot;messages&quot;: [...], }, &quot;storage&quot;: {...}, &quot;types&quot;: [...] } This file describes all the interfaces that can be used to interact with your contract: types provides the custom data types used throughout the rest of the JSON.storage defines all the storage items managed by your contract and how to ultimately access them.spec stores information about the callable functions like constructors and messages a user can call to interact with the contract. It also has helpful information like the eventsthat are emitted by the contract or any docs. If you look closely at the constructors and messages, you will also notice a selector which contains a 4-byte hash of the function name and is used to route your contract calls to the correct functions. In the next section we will start a Substrate Smart Contracts nodeand configure the Contracts UI to interact with it.","keywords":""},{"title":"Frequently Asked Questions","type":0,"sectionRef":"#","url":"faq","content":"","keywords":""},{"title":"Is it \"ink\" or \"ink!\"? What does the \"!\" stand for?​","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#is-it-ink-or-ink-what-does-the--stand-for","content":"The DSL (domain specific language) is spelled &quot;ink!&quot; with small &quot;i&quot; and an exclamation mark at the end. The main purpose behind this spelling is to have as many dots in its name as possible. "},{"title":"Who is \"Squink\"?​","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#who-is-squink","content":"This little cute purple squid is Squink. Squink is the mascot of ink! and guides new users and adventurers through our presentations workshops and tutorials. It also has a romance with Rust's mascot, Ferris. Generally it is very friendly and open to learning new Rustaceans but be aware to never upset it by taking away dots from the word ink! by spelling it incorrectly! It really is into dots. Stories tell that it demanded the spelling of ink! with as many dots as possible. "},{"title":"What's ink!'s relationship to Substrate/Polkadot?​","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#whats-inks-relationship-to-substratepolkadot","content":"Substrate is a modular framework to build decentralized applications on top of blockchain technology.Polkadot is a layer-0 blockchain built using Substrate that allows to orchestrate an entire fleet of other blockchains to join forces and communicate with each other.Blockchains built with Substrate can include the so-called contracts-pallet module in order to allow instantiating and executing smart contracts. ink! was built to allow users to write smart contracts in Rust targeting blockchains built by Substrate that have the aforementioned contracts-pallet included. While ink! is currently the most advanced smart contract language targeting Substrate blockchains it is not the only possible choice for users. There is also a Solidity to Wasm compiler called Solang that also allows to target Substrate chains and there are other languages in plan and discovery phase for the same purpose. On the Substrate side the same is true for the contracts-pallet. It is just a module that defines the basic set of features required for executing smart contracts on the blockchain that includes it. However, it is not necessarily the only solution to do exactly that. There is also the evm-palletto run smart contracts targeting the EVM as well as the experimental actors-pallet that allows to execute smart contracts written in the actor style programming model. Over time the Substrate community might come up with yet other pallets for smart contracts execution. "},{"title":"How to call other smart contracts on the same blockchain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-to-call-other-smart-contracts-on-the-same-blockchain","content":"See the Cross-contract calling section. "},{"title":"How to call other smart contracts on another parachain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-to-call-other-smart-contracts-on-another-parachain","content":"This feature has not yet been implemented by the Substrate side. "},{"title":"What is a contract's ABI or Metadata?​","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#what-is-a-contracts-abi-or-metadata","content":"In ink! a smart contract's metadata is retrieved by using the cargo-contract CLI tool and invoking cargo contract build which outputs a .contract file that includes both the compiled.wasm of the ink! smart contract as well as the so-called metadata information of the same smart contract. The metadata is especially important for third party tools such as Polkadot JS Apps or the Contracts UI and provides useful information about the contract's constructors, messages, events, function selectors, documentation and comments of the aforementioned structures as well as how inputs and outputs shall be encoded and decoded respectively etc. "},{"title":"Can a re-entrancy bug occur in ink! contracts?​","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#can-a-re-entrancy-bug-occur-in-ink-contracts","content":"Yes. However, the Substrate team is well aware of the associated problems and already through about possible future additions to eliminate re-entrancy attacks. "},{"title":"How can my smart contract interact with the runtime?​","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-can-my-smart-contract-interact-with-the-runtime","content":"See the Chain Extensions section for more information. "},{"title":"How can I use ink! with a Substrate chain with a custom chain config?​","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-can-i-use-ink-with-a-substrate-chain-with-a-custom-chain-config","content":"Please see the env_types argumentfor the contract macro. It allows you to specify your environment a la#[ink::contract(env = MyEnvironment)]. "},{"title":"What does the #![cfg_attr(not(feature = \"std\"), no_std)] at the beginning of each contract mean?​","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#what-does-the-cfg_attrnotfeature--std-no_std-at-the-beginning-of-each-contract-mean","content":"The #[cfg(..)] or #[cfg_attr(..)] annotations are how Rust does conditional compilation. ink! smart contracts can be compiled in two different modes. Through #![cfg_attr(not(feature = &quot;std&quot;), no_std)] an ink! smart contract tells the Rust compiler in which mode they are being compiled. This also plays a significant role in how ink! generates the smart contract code. The two modes are as follows: Wasm mode: This is the mode chosen when compiling an ink! smart contract for deployment on a blockchain. The resulting binary is a .wasm file and as such it is not possible to use certain parts of Rust's standard library.Off-chain mode: This is the mode chosen when trying to test an ink! smart contract using the off-chain environment. Off-chain environment testing is very useful to check if certain ink! constructors or messages are well behaving and allow for better debuggability than when trying to debug the same smart contract deployed on a chain. "},{"title":"Overflow Safety?​","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#overflow-safety","content":"Being written in Rust, ink! can provide compile-time overflow/underflow safety. Using a Rust compiler configuration, you can specify whether you want to support overflowing math, or if you want contract execution to panic when overflows occur. No need to continually import &quot;Safe Math&quot; libraries, although Rust also provides integrated checked, wrapped, and saturated math functions. Note: There are some known issues regarding functionality of compiler level overflow checks and the resulting size of the Wasm blob. This feature may change or be iterated on in the future. "},{"title":"What is the difference between memory and storage?​","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#what-is-the-difference-between-memory-and-storage","content":"In ink!, memory refers to computer memory, while storage refers to the on-chain storage used by a contract instance. Memory is temporary and only lasts until the contract execution is done, while storage is persistent and lasts over many contract executions. The contract storage is built on top of the runtime storage, and access is considered to be slow. "},{"title":"How do I print something to the console from the runtime?​","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-do-i-print-something-to-the-console-from-the-runtime","content":"You can use those two macros: ink_env::debug_println!ink_env::debug_print! There are three things you have to do for the debug messages to show up on the console: Enable the feature pallet-contracts/unstable-interface in the target runtime. For substrate-contracts-node this is done by default here. Enable the feature ink-debug for the ink_env crate. cargo-contract does this automatically for you (for versions &gt;= 0.13.0), except if you compile a contract in --release mode. Set the log level of your node to runtime::contracts=debug. For example, to have only errors and debug output show up for the substrate-contracts-node: substrate-contracts-node --dev --tmp -lerror,runtime::contracts=debug  Important: Debug output is only printed for RPC calls or off-chain tests ‒ not for transactions! In your ink! message or constructor you can write the following: #[ink(constructor)] fn new() -&gt; Self { ink_env::debug_println!(&quot;created new instance at {}&quot;, Self::env().block_number()); Self { } } #[ink(message)] fn print(&amp;self) { let caller = self.env().caller(); let message = ink_prelude::format!(&quot;got a call from {:?}&quot;, caller); ink_env::debug_println!(&amp;message); }  "},{"title":"Why is Rust's standard library (stdlib) not available in ink!?​","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#why-is-rusts-standard-library-stdlib-not-available-in-ink","content":"Rust's standard library consists of three different layers: core library which defines everything that has no dependencies outside of Rust itself. Included are types such as Option, Result as well as a whole variety of modules, functions and macro. ink! smart contracts allow authors to use Rust's core crate. alloc library which is depending on a global allocator and mainly defines collections that spill their elements on to the execution's heap memory. Examples for collections are Box, String, Vec, HashMap, LinkedList and modules such as fmt, rc (ref-counted pointers) or borrows. ink! smart contracts allow authors to use Rust's alloc crate. By default ink! authors use definitions from the alloc crate through ink_prelude crate. std library is what people generally call Rust's standard library. The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the broader Rust ecosystem. It requires several operating system capabilities in order to work correctly such as input and output systems for files, networking etc. Since the Wasm (a.k.a. wasm32-unknown-unknown) compilation target does not support Rust's standard library ink! authors cannot use it either for their own purposes. Instead the contracts-pallettries to provide some common functionality that would otherwise be missing for common smart contract operations. "},{"title":"Why is nightly required for ink!?​","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#why-is-nightly-required-for-ink","content":"ink! requires a nightly Rust compiler as of 2021-01 since it relies on a few unstable nightly features around allocation handlers for no_std (no standard library) code. As soon as the Rust team decides to stabilize these features ink! will be available for stable Rust. "},{"title":"How do I hash a value?​","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-do-i-hash-a-value","content":"A number of crypto hashes are built into the contracts-pallet and therefore very efficient to use. We currently support a handful of those, you can view the complete list here. If you have the urgent need for another crypto hash you could introduce it throughChain Extensionsor make a proposal to include it into the default set of the contracts-pallet. Using one of the built-in crypto hashes can be done as explained here: self.env().hash_bytes()self.env().hash_encoded() "},{"title":"Why is it not possible to use floating point data types in ink!? How do I implement returning a decimal number?​","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#why-is-it-not-possible-to-use-floating-point-data-types-in-ink-how-do-i-implement-returning-a-decimal-number","content":"Floats are cool for all kinds of reasons, but they also have one important drawback. Floating point arithmetic is non-deterministic which means that different processors compute (slightly) different results for the same operation. Although there is an IEEE spec, non-determinism can come from specific libraries used, or even hardware. In order for the nodes in a blockchain network to reach agreement on the state of the chain, all operations must be completely deterministic. Hence we don't allow floating point data types in ink!. Consequently it's not possible to return a decimal number from an ink! message. What you should do instead is to have your user interface denominate the returned number to decimals. Note, that it's typical for blockchains to have the number of available tokens defined as a non-floating number and determine the denomination in the user interface. For example, 1 Bitcoin is equivalent to the smallest unit of 100,000,000 Satoshi and all Bitcoin implementations internally persist account balances in Satoshi, not as a decimal number of Bitcoin. "},{"title":"Why can't I just use the standard Rust data collections in ink!?​","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#why-cant-i-just-use-the-standard-rust-data-collections-in-ink","content":"You can use them! They are exposed via the ink_prelude crate (e.g. ink_prelude::vec::Vec) and you can return them from ink! messages and also persist them to storage. However, the Rust stdlib collections are not optimized for smart contract usage! So for example, if you use them to persist your data on the chain they will always occupy a single storage cell and thus always be loaded eagerly, in their entirety. This can be very costly! Just think about a Vec or a HashMap where the smart contract might only need access to a few elements, rather than the entire data collection. "},{"title":"Why am I getting a ContractTrapped error when interacting with a contract?​","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#why-am-i-getting-a-contracttrapped-error-when-interacting-with-a-contract","content":"When it does not constitute a deliberate assertion, like for example a permission check, it is most likely a bug in your contract or in ink!. A common source of ContractTrapped are Integer overflows, those can cause your contract to trap as well. There is a known bug in the Rust compilerwith respect to safe math operations. As a workaround for this particular bug try to insert overflow-checks = false into your Cargo.toml. This will disable safe math operations altogether, but unfortunately we are currently not aware of a better workaround until the bug in the compiler is fixed. If you don't find the issue you can also ask for help in our publicElement orDiscord channel. "},{"title":"What are the scale::Encode and scale::Decode traits?​","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#what-are-the-scaleencode-and-scaledecode-traits","content":"Substrate-based blockchains use the SCALE codecto encode data. As a consequence the data for every interaction with Substrate needs to be SCALE-encodable ‒ i.e. it needs to implement either scale::Encode,scale::Decode, or both. This affects e.g. data you want to return to a caller, data that you want to take as input, or data you want to store on-chain. A common error you might get when a necessary SCALE trait is not implemented for a data structure could be along the lines of the trait &quot;WrapperTypeEncode&quot; is not implemented for &quot;Foo&quot;. For example, you might encounter this error if you try to store a custom data structure in the contract's storage. Or e.g. when attempting to return a custom error from an ink! message. Note: The error the trait &quot;WrapperTypeEncode&quot; is not implemented for … is also a common error when a mismatching version of parity-scale-codec is used in the contract opposed to the version used by ink!. The solution typically is to add a fitting implementation of the trait for your data structure: Encode is used for encoding a data structure when it is e.g. returned to a caller or when it is persisted to the contracts storage.Decode is used for the inverse, e.g. when reading from storage or taking an input from a user (or another contract). It's possible to derive those traits and oftentimes the simplest way is to just derive the missing trait for the object for which its implementation is missing: #[derive(scale::Encode, scale::Decode)] struct MyCustomDataStructure { … }  "},{"title":"How do I use String in my contract?​","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-do-i-use-string-in-my-contract","content":"In general, you should think twice if you really need String. Smart contracts usually don't use strings; those are typically used for user interactions and should live in your UI and not on the chain. Minimizing storage usage of your contract is a best practice and you should only persist items which you need to derive state transitions in your contract. If you still, for some reason, need to use String, then you should use the String from the ink! prelude. "},{"title":"Call Your Contract","type":0,"sectionRef":"#","url":"getting-started/calling-your-contract","content":"","keywords":""},{"title":"1. get() function​","type":1,"pageTitle":"Call Your Contract","url":"getting-started/calling-your-contract#1-get-function","content":"We set the initial value of the Flipper contractvalue to false when we instantiated the contract. Let's check that this is the case. In the Message to Send section, select the &quot;get(): bool&quot; message and accept the default values for the other options. Press &quot;Read&quot; and confirm that it returns the value false:  "},{"title":"2. flip() function​","type":1,"pageTitle":"Call Your Contract","url":"getting-started/calling-your-contract#2-flip-function","content":"So let's make the value turn true now! The alternative message to send with the UI is flip(). Again, accept the default values for the other options and click Call  If the transaction was successful, we should then be able to go back to the get() function and see our updated storage:  Woohoo! You deployed your first smart contract! "},{"title":"Deploy Your Contract","type":0,"sectionRef":"#","url":"getting-started/deploy-your-contract","content":"","keywords":""},{"title":"1. Upload Contract Code​","type":1,"pageTitle":"Deploy Your Contract","url":"getting-started/deploy-your-contract#1-upload-contract-code","content":"Here we will upload the contract code and instantiate one copy of the contract on the blockchain (which is usually why we upload the contract code in the first place): Click the Add New Contract button in the sidebar.Click the Upload New Contract Code button in the Add New Contract page.Choose an Instantiation account (e.g. ALICE).Give the contract a descriptive Name (e.g. Flipper Contract).Drag the flipper.contract file that contains the bundled Wasm blob and metadata into the drag &amp; drop area. You will see the UI parse the metadata and enabling the button that takes you to the next step.Click the Next button  "},{"title":"2. Instantiate a Contract on the Blockchain​","type":1,"pageTitle":"Deploy Your Contract","url":"getting-started/deploy-your-contract#2-instantiate-a-contract-on-the-blockchain","content":"Smart contracts exist as an extension of the account system on the blockchain. Thus creating an instance of this contract will create a new AccountId which will store any balance managed by the smart contract and allow us to interact with the contract. Now a screen displays the information that represents our smart contract. We are going to instantiate a copy of the smart contract: Accept the default options for the contract Deployment Constructor.Accept the default options Max Gas Allowed of 200000.Click on Next  The transaction is now queued, review your data and click Upload and Instantiate or go back and modify your inputs.  When you click Upload and Instantiate you should see the extrinsic instantiateWithCode is processing, and a flurry of events appear including the creation of a new account (system.NewAccount) and the instantiation of the contract (contracts.Instantiated). You will be redirected to a new page, where you can interact with the newly created contract instance.  "},{"title":"Creating an ink! Project","type":0,"sectionRef":"#","url":"getting-started/creating-an-ink-project","content":"","keywords":""},{"title":"Contract Source Code​","type":1,"pageTitle":"Creating an ink! Project","url":"getting-started/creating-an-ink-project#contract-source-code","content":"The ink CLI automatically generates the source code for the &quot;Flipper&quot; contract, which is about the simplest &quot;smart&quot; contract you can build. You can take a sneak peak as to what will come by looking at the source code here: Flipper Example Source Code The Flipper contract is nothing more than a bool which gets flipped from true to false through the flip() function. "},{"title":"Testing Your Contract​","type":1,"pageTitle":"Creating an ink! Project","url":"getting-started/creating-an-ink-project#testing-your-contract","content":"You will see at the bottom of the source code there are simple test cases which verify the functionality of the contract. We can quickly test this code is functioning as expected using the off-chain test environment that ink! provides. In your project folder run: cargo +nightly test  To which you should see a successful test completion: $ cargo +nightly test running 2 tests test flipper::tests::it_works ... ok test flipper::tests::default_works ... ok test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out  Now that we are feeling confident things are working, we can actually compile this contract to Wasm in the next step. "},{"title":"Run a Substrate Node","type":0,"sectionRef":"#","url":"getting-started/running-substrate","content":"Run a Substrate Node The substrate-contracts-node is a simple Substrate blockchain which is configured to include the contracts module. It's a comfortable option if you want to get a quickstart. After successfully installing substrate-contracts-node, you can start a local development chain by running: substrate-contracts-node --dev --tmp You should start to see blocks being produced by your node in your terminal. You can interact with your node using the Contracts UI: https://github.com/paritytech/contracts-ui Now configure the UI to connect to the locally running node: Click on the dropdown selector at top left corner.Choose the Local Node.","keywords":""},{"title":"Troubleshooting","type":0,"sectionRef":"#","url":"getting-started/troubleshooting","content":"","keywords":""},{"title":"Unexpected Epoch Change​","type":1,"pageTitle":"Troubleshooting","url":"getting-started/troubleshooting#unexpected-epoch-change","content":"There is a known issue with the Substrate block production (BABE) on a running chain. If you stop your node for too long (closing the terminal, putting your computer to sleep, etc.), you will get the following error: ClientImport(&quot;Unexpected epoch change&quot;)  To solve this you will need to restart your node with: substrate-contracts-node --dev --tmp. At that point, you will need to re-deploy any contracts and re-do any steps that you may have done before on your node. As long as you keep your node running, you should face no issues. "},{"title":"Old Contracts in Local Storage​","type":1,"pageTitle":"Troubleshooting","url":"getting-started/troubleshooting#old-contracts-in-local-storage","content":"Contracts UI uses its own local storage to track the contracts that you have deployed. This means that if you deploy a contract using the UI, and then purge your Substrate node, you will be prompted to reset your local storage and please do so. And then re-deploy any contracts and re-do any steps that you may have done before on your node. "},{"title":"Other Issues​","type":1,"pageTitle":"Troubleshooting","url":"getting-started/troubleshooting#other-issues","content":"If you run into any other issues during this tutorial, please report an issue! "},{"title":"Setup","type":0,"sectionRef":"#","url":"getting-started/setup","content":"","keywords":""},{"title":"Rust & Cargo​","type":1,"pageTitle":"Setup","url":"getting-started/setup#rust--cargo","content":"A pre-requisite for compiling smart contracts is to have Rust and Cargo installed. Here's an installation guide. "},{"title":"ink! CLI​","type":1,"pageTitle":"Setup","url":"getting-started/setup#ink-cli","content":"The first tool we will be installing is cargo-contract, a CLI tool for helping setting up and managing WebAssembly smart contracts written with ink!. As a pre-requisite for the tool you need to install the binaryen package, which is used to optimize the WebAssembly bytecode of the contract. Two other dependencies are needed to lint the ink! contract. This is done to warn users about using e.g. API's in a way that could lead to security issues. cargo install cargo-dylint dylint-link  Many package managers have it available nowadays ‒ e.g. there is a package for Debian/Ubuntu,Homebrew and Arch Linux. If there's only an old version in your distributions package manager you can also download a binary release directly. After you've installed the package execute: cargo install cargo-contract --force --locked  Use the --force to ensure you are updated to the most recent cargo-contract version. You can then use cargo contract --help to start exploring the commands made available to you. "},{"title":"Substrate Framework Pre-requisites​","type":1,"pageTitle":"Setup","url":"getting-started/setup#substrate-framework-pre-requisites","content":"With ink! you can write smart contracts for blockchains built on Substrate. Follow theofficial installation steps from the Substrate Developer Hub Knowledge Base to set up all Substrate pre-requisites. Once you have done this you will also need to run: rustup component add rust-src --toolchain nightly rustup target add wasm32-unknown-unknown --toolchain nightly  "},{"title":"Installing The Substrate Smart Contracts Node​","type":1,"pageTitle":"Setup","url":"getting-started/setup#installing-the-substrate-smart-contracts-node","content":"The substrate-contracts-node is a simple Substrate blockchain which is configured to include the Substrate module for smart contract functionality ‒ the contracts pallet (see How it Works for more). It's a comfortable option if you want to get a quickstart. You can download a binary from our releases page(Linux and Mac). Alternatively you can build the node by yourself: cargo install contracts-node --git https://github.com/paritytech/substrate-contracts-node.git --tag v0.12.0 --force --locked  "},{"title":"How it Works ‒ Substrate","type":0,"sectionRef":"#","url":"how-it-works","content":"How it Works ‒ Substrate Substrate's Framework for Runtime Aggregation of Modularised Entities (FRAME) contains a module which implements an API for typical functions smart contracts need (storage, querying information about accounts, …). This module is called the contracts pallet, you can find its repository here. The contracts pallet requires smart contracts to be uploaded to the blockchain as a Wasm blob. ink! is a smart contract language which targets the API exposed by contracts. Hence ink! contracts are compiled to Wasm. When executing cargo contract build an additional file metadata.json is created. It contains information about e.g. what methods the contract provides for others to call.","keywords":""},{"title":"ink! vs. CosmWasm","type":0,"sectionRef":"#","url":"ink-vs-cosmwasm","content":"","keywords":""},{"title":"Dependencies​","type":1,"pageTitle":"ink! vs. CosmWasm","url":"ink-vs-cosmwasm#dependencies","content":"The first step in CosmWasm development is toinstall dependencies, namely Go, Rust and wasmd. For ink! you can also find a setup guide which will help you with dependencies, namely Rust, cargo-contract and substrate-contracts-node. "},{"title":"Environment Setup​","type":1,"pageTitle":"ink! vs. CosmWasm","url":"ink-vs-cosmwasm#environment-setup","content":"The next step in the CosmWasm development workflow issetting up the environment. That consists mainly of configuring wasmd such that it has prefunded accounts that are able to interact with the network. When substrate-contracts-node is started with the --dev flag, it already contains well known pre-funded accounts (alice, bob, etc.) which are ready to be used for development. "},{"title":"Compile and Test​","type":1,"pageTitle":"ink! vs. CosmWasm","url":"ink-vs-cosmwasm#compile-and-test","content":"CosmWasm provides example contracts at thecw-contracts repository. After the repository is cloned, from the contract directory it can be compiled via: $ cargo wasm  and tested via: $ cargo unit-test  Similarly, ink! provides anexamples directory of its main repository. A contract can be compiled from its directory via: $ cargo +nightly contract build  and tested via: $ cargo test  "},{"title":"Deploy and Interact​","type":1,"pageTitle":"ink! vs. CosmWasm","url":"ink-vs-cosmwasm#deploy-and-interact","content":"CosmWasm contracts are deployed and instantiated with help of the wasmd executable. The list of step is provided here. It is possible to deploy and interact with ink! contracts using either a CLI (cargo-contract), or a web UI (contracts-ui). Instructions for cargo-contractInstructions for contracts-ui "},{"title":"ink! vs. Solidity","type":0,"sectionRef":"#","url":"ink-vs-solidity","content":"ink! vs. Solidity Here is a brief comparison of features between ink! and Solidity: ink!\tSolidityVirtual Machine\tAny Wasm VM\tEVM Encoding\tWasm\tEVM Byte Code Language\tRust\tStandalone Overflow Protection\tEnabled by default\tNone Constructor Functions\tMultiple\tSingle Tooling\tAnything that supports Rust\tCustom Versioning\tSemantic\tSemantic Has Metadata?\tYes\tYes Multi-File Project\tPlanned\tYes Storage Entries\tVariable\t256 bits Supported Types\tDocs\tDocs Has Interfaces?\tYes (Rust Traits)\tYes","keywords":""},{"title":"Overview","type":0,"sectionRef":"#","url":"macros-attributes","content":"","keywords":""},{"title":"Merging Attributes​","type":1,"pageTitle":"Overview","url":"macros-attributes#merging-attributes","content":"It is possible to merge attributes that share a common flagged entity. The example below demonstrates this for a payable message with a custom selector. #[ink(message)] #[ink(payable)] #[ink(selector = &quot;0xCAFEBABE&quot;)] pub fn transfer(&amp;mut self, from: AccountId, to: AccountId, value: Balance) -&gt; Result&lt;(), Error&gt; { // actual implementation }  We can also write the above ink! message definition in the following way: #[ink(message, payable, selector = &quot;0xCAFEBABE&quot;)] pub fn transfer(&amp;mut self, from: AccountId, to: AccountId, value: Balance) -&gt; Result&lt;(), Error&gt; { // actual implementation }  "},{"title":"#[ink(anonymous)]","type":0,"sectionRef":"#","url":"macros-attributes/anonymous","content":"#[ink(anonymous)] Applicable to ink! events. Tells the ink! codegen to treat the ink! event as anonymous which omits the event signature as topic upon emitting. Very similar to anonymous events in Solidity. Anonymous events have similar semantics as in Solidity in that their event signature won't be included in their event topics serialization to reduce event emitting overhead. This is especially useful for user defined events. The signature of the event is by default one of the topics of the event, except if you annotate the event with #[ink(anonymous)]. The attribute implies that it is not possible to filter for specific anonymous events by name.","keywords":""},{"title":"#[ink(constructor)]","type":0,"sectionRef":"#","url":"macros-attributes/constructor","content":"","keywords":""},{"title":"Example​","type":1,"pageTitle":"#[ink(constructor)]","url":"macros-attributes/constructor#example","content":"use ink_lang as ink; #[ink::contract] mod erc20 { #[ink(storage)] pub struct Erc20 { ... } impl Erc20 { #[ink(constructor)] pub fn new(initial_supply: Balance) -&gt; Self { .. } #[ink(constructor)] pub fn total_supply(&amp;self) -&gt; Balance { .. } // etc. } }  "},{"title":"#[ink::chain_extension]","type":0,"sectionRef":"#","url":"macros-attributes/chain-extension","content":"","keywords":""},{"title":"Structure​","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#structure","content":"The interface consists of an error code that indicates lightweight errors as well as the definition of some chain extension methods. The overall structure follows that of a simple Rust trait definition. The error code is defined as an associated type definition of the trait definition. The methods are defined as associated trait methods without implementation. Chain extension methods must not have a self receiver such as &amp;self or &amp;mut selfand must have inputs and output that implement SCALE codec. Their return value follows specific rules that can be altered using the handle_status and returns_result attributes which are described in more detail below. "},{"title":"Usage​","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#usage","content":"Usually the chain extension definition using this proc. macro is provided by the author of the chain extension in a separate crate. ink! smart contracts using this chain extension simply depend on this crate and use its associated environment definition in order to make use of the methods provided by the chain extension. "},{"title":"#[ink::contract]","type":0,"sectionRef":"#","url":"macros-attributes/contract","content":"","keywords":""},{"title":"Header Arguments​","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#header-arguments","content":"The #[ink::contract] macro can be provided with some additional comma-separated header arguments: "},{"title":"compile_as_dependency: bool​","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#compile_as_dependency-bool","content":"Tells the ink! code generator to always or nevercompile the smart contract as if it was used as a dependency of another ink! smart contract. Normally this flag is only really useful for ink! developers who want to inspect code generation of ink! smart contracts. The author is not aware of any particular practical use case for users that makes use of this flag but contract writers are encouraged to disprove this. Note that it is recommended to make use of the built-in crate featureink-as-dependency to flag smart contract dependencies listed in a contract'sCargo.toml as actual dependencies to ink!. Usage Example: use ink_lang as ink; #[ink::contract(compile_as_dependency = true)] mod my_contract { #[ink(storage)] pub struct MyStorage; impl MyStorage { #[ink(constructor)] pub fn construct() -&gt; Self { MyStorage {} } #[ink(message)] pub fn message(&amp;self) {} } // ... }  Default value: Depends on the crate feature propagation of Cargo.toml. "},{"title":"env: impl Environment​","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#env-impl-environment","content":"Tells the ink! code generator which environment to use for the ink! smart contract. The environment must implement the Environment (defined in ink_env) trait and provides all the necessary fundamental type definitions for Balance, AccountId etc. When using a custom Environment implementation for a smart contract all types that it exposes to the ink! smart contract and the mirrored types used in the runtime must be aligned with respect to SCALE encoding and semantics. Usage Example: Given a custom Environment implementation: pub struct MyEnvironment; impl ink_env::Environment for MyEnvironment { const MAX_EVENT_TOPICS: usize = 3; type AccountId = u64; type Balance = u128; type Hash = [u8; 32]; type Timestamp = u64; type BlockNumber = u32; type ChainExtension = ::ink_env::NoChainExtension; }  A user might implement their ink! smart contract using the above custom Environmentimplementation as demonstrated below: use ink_lang as ink; #[ink::contract(env = MyEnvironment)] mod my_contract { pub struct MyEnvironment; impl ink_env::Environment for MyEnvironment { const MAX_EVENT_TOPICS: usize = 3; type AccountId = u64; type Balance = u128; type Hash = [u8; 32]; type Timestamp = u64; type BlockNumber = u32; type ChainExtension = ::ink_env::NoChainExtension; } #[ink(storage)] pub struct MyStorage; impl MyStorage { #[ink(constructor)] pub fn construct() -&gt; Self { MyStorage {} } #[ink(message)] pub fn message(&amp;self) {} } // ... }  Default value: DefaultEnvironment defined in ink_env crate. "},{"title":"Anaylsis​","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#anaylsis","content":"The #[ink::contract] macro fully analyses its input smart contract against invalid arguments and structure. Some example rules include but are not limited to: There must be exactly one #[ink(storage)] struct. This struct defines the layout of the storage that the ink! smart contract operates on. The user is able to use a variety of built-in facilities, combine them in various ways or even provide their own implementations of storage data structures. For more information visit the ink_storage crate documentation. Example: use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] pub fn construct() -&gt; Self { Flipper { value: false } } #[ink(message)] pub fn message(&amp;self) {} } } There must be at least one #[ink(constructor)] defined method. Methods flagged with #[ink(constructor)] are special in that they are dispatchable upon contract instantiation. A contract may define multiple such constructors which allow users of the contract to instantiate a contract in multiple different ways. Example: Given the Flipper contract definition above we add an #[ink(constructor)]as follows: use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] pub fn new(initial_value: bool) -&gt; Self { Flipper { value: false } } #[ink(message)] pub fn message(&amp;self) {} } } There must be at least one #[ink(message)] defined method. Methods flagged with #[ink(message)] are special in that they are dispatchable upon contract invocation. The set of ink! messages defined for an ink! smart contract define its API surface with which users are allowed to interact. An ink! smart contract can have multiple such ink! messages defined. Note: An ink! message with a &amp;self receiver may only read state whereas an ink! message with a &amp;mut self receiver may mutate the contract's storage. Example: Given the Flipper contract definition above we add some #[ink(message)] definitions as follows: use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] pub fn new(initial_value: bool) -&gt; Self { Flipper { value: false } } /// Flips the current value. #[ink(message)] pub fn flip(&amp;mut self) { self.value = !self.value; } /// Returns the current value. #[ink(message)] pub fn get(&amp;self) -&gt; bool { self.value } } } Payable Messages: An ink! message by default will reject calls that additional fund the smart contract. Authors of ink! smart contracts can make an ink! message payable by adding the payableflag to it. An example below: Note that ink! constructors are always implicitly payable and thus cannot be flagged as such. use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] pub fn new(initial_value: bool) -&gt; Self { Flipper { value: false } } /// Flips the current value. #[ink(message)] #[ink(payable)] // You can either specify payable out-of-line. pub fn flip(&amp;mut self) { self.value = !self.value; } /// Returns the current value. #[ink(message, payable)] // ...or specify payable inline. pub fn get(&amp;self) -&gt; bool { self.value } } } Controlling the messages selector: Every ink! message and ink! constructor has a unique selector with which the message or constructor can be uniquely identified within the ink! smart contract. These selectors are mainly used to drive the contract's dispatch upon calling it. An ink! smart contract author can control the selector of an ink! message or ink! constructor using the selector flag. An example is shown below: use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] #[ink(selector = &quot;0xDEADBEEF&quot;)] // Works on constructors as well. pub fn new(initial_value: bool) -&gt; Self { Flipper { value: false } } /// Flips the current value. #[ink(message)] #[ink(selector = &quot;0xCAFEBABE&quot;)] // You can either specify selector out-of-line. pub fn flip(&amp;mut self) { self.value = !self.value; } /// Returns the current value. #[ink(message, selector = &quot;0xFEEDBEEF&quot;)] // ...or specify selector inline. pub fn get(&amp;self) -&gt; bool { self.value } } }  "},{"title":"Interacting with the Contract Executor​","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#interacting-with-the-contract-executor","content":"The ink_env crate provides facitilies to interact with the contract executor that connects ink! smart contracts with the outer world. For example it is possible to query the current call's caller via: use ink_env; ink_env::test::run_test::&lt;ink_env::DefaultEnvironment, _&gt;(|_| { let caller = ink_env::caller::&lt;ink_env::DefaultEnvironment&gt;(); let _caller = caller; Ok(()) }).unwrap();  However, ink! provides a much simpler way to interact with the contract executor via its environment accessor. An example below: use ink_lang as ink; #[ink::contract] mod greeter { #[ink(storage)] pub struct Greeter; impl Greeter { #[ink(constructor)] pub fn new() -&gt; Self { let caller = Self::env().caller(); let message = format!(&quot;thanks for instantiation {:?}&quot;, caller); ink_env::debug_println(&amp;message); Greeter {} } #[ink(message, payable)] pub fn fund(&amp;mut self) { let caller = self.env().caller(); let value = self.env().transferred_balance(); let message = format!(&quot;thanks for the funding of {:?} from {:?}&quot;, value, caller); ink_env::debug_println(&amp;message); } } }  "},{"title":"Events​","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#events","content":"An ink! smart contract may define events that it can emit during contract execution. Emitting events can be used by third party tools to query information about a contract's execution and state. The following example ink! contract shows how an event Transferred is defined and emitted in the #[ink(constructor)].  use ink_lang as ink; #[ink::contract] mod erc20 { /// Defines an event that is emitted every time value is transferred. #[ink(event)] pub struct Transferred { from: Option&lt;AccountId&gt;, to: Option&lt;AccountId&gt;, value: Balance, } #[ink(storage)] pub struct Erc20 { total_supply: Balance, // more fields ... } impl Erc20 { #[ink(constructor)] pub fn new(initial_supply: Balance) -&gt; Self { let caller = Self::env().caller(); Self::env().emit_event(Transferred { from: None, to: Some(caller), value: initial_supply, }); Self { total_supply: initial_supply } } #[ink(message)] pub fn total_supply(&amp;self) -&gt; Balance { self.total_supply } } }  "},{"title":"Example: Flipper​","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#example-flipper","content":"The below code shows the complete implementation of the so-called Flipper ink! smart contract. For us it acts as the &quot;Hello, World!&quot; of the ink! smart contracts because it is minimal while still providing some more or less useful functionality. It controls a single bool value that can be either false or trueand allows the user to flip this value using the Flipper::flip message or retrieve the current value using Flipper::get. use ink_lang as ink; #[ink::contract] pub mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { /// Creates a new flipper smart contract initialized with the given value. #[ink(constructor)] pub fn new(init_value: bool) -&gt; Self { Self { value: init_value } } /// Flips the current value of the Flipper's bool. #[ink(message)] pub fn flip(&amp;mut self) { self.value = !self.value; } /// Returns the current value of the Flipper's bool. #[ink(message)] pub fn get(&amp;self) -&gt; bool { self.value } } }  "},{"title":"Attributes​","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#attributes","content":"There are three different attributes with which the chain extension methods can be flagged: Attribute\tRequired\tDefault Value\tDescriptionink(extension = N: u32)\tYes\t-\tDetermines the unique function ID of the chain extension method. ink(handle_status = flag: bool)\tOptional\ttrue\tAssumes that the returned status code of the chain extension method always indicates success and therefore always loads and decodes the output buffer of the call. ink(returns_result = flag: bool)\tOptional\ttrue\tBy default chain extension methods are assumed to return a Result&lt;T, E&gt; in the output buffer. Using returns_result = false this check is disabled and the chain extension method may return any other type. As with all ink! attributes multiple of them can either appear in a contiguous list: type Access = i32; use ink_lang as ink; #[ink::chain_extension] pub trait MyChainExtension { type ErrorCode = i32; #[ink(extension = 5, handle_status = false, returns_result = false)] fn key_access_for_account(key: &amp;[u8], account: &amp;[u8]) -&gt; Access; }  …or as multiple standalone ink! attributes applied to the same item: type Access = i32; use ink_lang as ink; #[ink::chain_extension] pub trait MyChainExtension { type ErrorCode = i32; #[ink(extension = 5)] #[ink(handle_status = false)] #[ink(returns_result = false)] fn key_access_for_account(key: &amp;[u8], account: &amp;[u8]) -&gt; Access; }  "},{"title":"Details: handle_status​","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#details-handle_status","content":"Default value: true By default all chain extension methods return a Result&lt;T, E&gt; where E: From&lt;Self::ErrorCode&gt;. The Self::ErrorCode represents the error code of the chain extension. This means that a smart contract calling such a chain extension method first queries the returned status code of the chain extension method and only loads and decodes the output if the returned status code indicates a successful call. This design was chosen as it is more efficient when no output besides the error code is required for a chain extension call. When designing a chain extension try to utilize the error code to return errors and only use the output buffer for information that does not fit in a single u32 value. A chain extension method that is flagged with handle_status = false assumes that the returned error code will always indicate success. Therefore it will always load and decode the output buffer and loses the E: From&lt;Self::ErrorCode constraint for the call. "},{"title":"Details: returns_result​","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#details-returns_result","content":"Default value: true By default chain extension methods are assumed to return a value of type Result&lt;T, E&gt; through the output buffer. Using returns_result = false this check is disabled and the chain extension method may return any other type. Note that if a chain extension method is attributed with returns_result = falseand with handle_status = true it will still return a value of type Result&lt;T, Self::ErrorCode&gt;. "},{"title":"Usage: handle_status + returns_result​","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#usage-handle_status--returns_result","content":"Use both handle_status = false and returns_result = false for the same chain extension method if a call to it may never fail and never returns a Result type. "},{"title":"Combinations​","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#combinations","content":"Due to the possibility to flag a chain extension method with handle_status and returns_resultthere are 4 different cases with slightly varying semantics: handle_status\treturns_result\tEffectstrue\ttrue\tThe chain extension method is required to return a value of type Result&lt;T, E&gt; where E: From&lt;Self::ErrorCode&gt;. A call will always check if the returned status code indicates success and only then will load and decode the value in the output buffer. true\tfalse\tThe chain extension method may return any non-Result type. A call will always check if the returned status code indicates success and only then will load and decode the value in the output buffer. The actual return type of the chain extension method is still Result&lt;T, Self::ErrorCode&gt; when the chain extension method was defined to return a value of type T. false\ttrue\tThe chain extension method is required to return a value of type Result&lt;T, E&gt;. A call will always assume that the returned status code indicates success and therefore always load and decode the output buffer directly. false\tfalse\tThe chain extension method may return any non-Result type. A call will always assume that the returned status code indicates success and therefore always load and decode the output buffer directly. "},{"title":"Error Code​","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#error-code","content":"Every chain extension defines exactly one ErrorCode using the following syntax: use ink_lang as ink; #[ink::chain_extension] pub trait MyChainExtension { type ErrorCode = MyErrorCode; // more definitions ... }  The defined ErrorCode must implement FromStatusCode which should be implemented as a more or less trivial conversion from the u32 status code to a Result&lt;(), Self::ErrorCode&gt;. The Ok(()) value indicates that the call to the chain extension method was successful. By convention an error code of 0 represents success. However, chain extension authors may use whatever suits their needs. "},{"title":"Example: Definition​","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#example-definition","content":"In the below example a chain extension is defined that allows its users to read and write from and to the runtime storage using access privileges: use ink_lang as ink; /// Custom chain extension to read to and write from the runtime. #[ink::chain_extension] pub trait RuntimeReadWrite { type ErrorCode = ReadWriteErrorCode; /// Reads from runtime storage. /// /// # Note /// /// Actually returns a value of type `Result&lt;Vec&lt;u8&gt;, Self::ErrorCode&gt;`. /// #[ink(extension = 1, returns_result = false)] /// fn read(key: &amp;[u8]) -&gt; Vec&lt;u8&gt;; /// /// Reads from runtime storage. /// /// Returns the number of bytes read and up to 32 bytes of the /// read value. Unused bytes in the output are set to 0. /// /// # Errors /// /// If the runtime storage cell stores a value that requires more than /// 32 bytes. /// /// # Note /// /// This requires `ReadWriteError` to implement `From&lt;ReadWriteErrorCode&gt;` /// and may potentially return any `Self::ErrorCode` through its return value. #[ink(extension = 2)] fn read_small(key: &amp;[u8]) -&gt; Result&lt;(u32, [u8; 32]), ReadWriteError&gt;; /// Writes into runtime storage. /// /// # Note /// /// Actually returns a value of type `Result&lt;(), Self::ErrorCode&gt;`. #[ink(extension = 3, returns_result = false)] fn write(key: &amp;[u8], value: &amp;[u8]); /// Returns the access allowed for the key for the caller. /// /// # Note /// /// Assumes to never fail the call and therefore always returns `Option&lt;Access&gt;`. #[ink(extension = 4, returns_result = false, handle_status = false)] fn access(key: &amp;[u8]) -&gt; Option&lt;Access&gt;; /// Unlocks previously aquired permission to access key. /// /// # Errors /// /// If the permission was not granted. /// /// # Note /// /// Assumes the call to never fail and therefore does _NOT_ require `UnlockAccessError` /// to implement `From&lt;Self::ErrorCode&gt;` as in the `read_small` method above. #[ink(extension = 5, handle_status = false)] fn unlock_access(key: &amp;[u8], access: Access) -&gt; Result&lt;(), UnlockAccessError&gt;; } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub enum ReadWriteErrorCode { InvalidKey, CannotWriteToKey, CannotReadFromKey, } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub enum ReadWriteError { ErrorCode(ReadWriteErrorCode), BufferTooSmall { required_bytes: u32 }, } impl From&lt;ReadWriteErrorCode&gt; for ReadWriteError { fn from(error_code: ReadWriteErrorCode) -&gt; Self { Self::ErrorCode(error_code) } } impl From&lt;scale::Error&gt; for ReadWriteError { fn from(_: scale::Error) -&gt; Self { panic!(&quot;encountered unexpected invalid SCALE encoding&quot;) } } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub struct UnlockAccessError { reason: String, } impl From&lt;scale::Error&gt; for UnlockAccessError { fn from(_: scale::Error) -&gt; Self { panic!(&quot;encountered unexpected invalid SCALE encoding&quot;) } } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub enum Access { ReadWrite, ReadOnly, WriteOnly, } impl ink_env::chain_extension::FromStatusCode for ReadWriteErrorCode { fn from_status_code(status_code: u32) -&gt; Result&lt;(), Self&gt; { match status_code { 0 =&gt; Ok(()), 1 =&gt; Err(Self::InvalidKey), 2 =&gt; Err(Self::CannotWriteToKey), 3 =&gt; Err(Self::CannotReadFromKey), _ =&gt; panic!(&quot;encountered unknown status code&quot;), } } }  All the error types and other utility types used in the chain extension definition above are often required to implement various traits such as SCALE's Encode and Decodeas well as scale-info's TypeInfo trait. A full example of the above chain extension definition can be seenhere. "},{"title":"Example: Environment​","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#example-environment","content":"In order to allow ink! smart contracts to use the above defined chain extension it needs to be integrated into an Environment definition as shown below: type RuntimeReadWrite = i32; use ink_env::{Environment, DefaultEnvironment}; pub enum CustomEnvironment {} impl Environment for CustomEnvironment { const MAX_EVENT_TOPICS: usize = &lt;DefaultEnvironment as Environment&gt;::MAX_EVENT_TOPICS; type AccountId = &lt;DefaultEnvironment as Environment&gt;::AccountId; type Balance = &lt;DefaultEnvironment as Environment&gt;::Balance; type Hash = &lt;DefaultEnvironment as Environment&gt;::Hash; type BlockNumber = &lt;DefaultEnvironment as Environment&gt;::BlockNumber; type Timestamp = &lt;DefaultEnvironment as Environment&gt;::Timestamp; type ChainExtension = RuntimeReadWrite; }  Above we defined the CustomEnvironment which defaults to ink!'s DefaultEnvironmentfor all constants and types but the ChainExtension type which is assigned to our newly defined chain extension. "},{"title":"Example: Usage​","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#example-usage","content":"An ink! smart contract can use the above defined chain extension through the Environmentdefinition defined in the last example section using the env macro parameter as shown below. Note that chain extension methods are accessible through Self::extension() orself.extension(). For example as in Self::extension().read(..) or self.extension().read(..). use ink_lang as ink; #[ink::contract(env = CustomEnvironment)] mod read_writer { use ink_lang as ink; #[ink(storage)] pub struct ReadWriter {} impl ReadWriter { #[ink(constructor)] pub fn new() -&gt; Self { Self {} } #[ink(message)] pub fn read(&amp;self, key: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, ReadWriteErrorCode&gt; { self.env() .extension() .read(&amp;key) } #[ink(message)] pub fn read_small(&amp;self, key: Vec&lt;u8&gt;) -&gt; Result&lt;(u32, [u8; 32]), ReadWriteError&gt; { self.env() .extension() .read_small(&amp;key) } #[ink(message)] pub fn write( &amp;self, key: Vec&lt;u8&gt;, value: Vec&lt;u8&gt;, ) -&gt; Result&lt;(), ReadWriteErrorCode&gt; { self.env() .extension() .write(&amp;key, &amp;value) } #[ink(message)] pub fn access(&amp;self, key: Vec&lt;u8&gt;) -&gt; Option&lt;Access&gt; { self.env() .extension() .access(&amp;key) } #[ink(message)] pub fn unlock_access(&amp;self, key: Vec&lt;u8&gt;, access: Access) -&gt; Result&lt;(), UnlockAccessError&gt; { self.env() .extension() .unlock_access(&amp;key, access) } } /// Custom chain extension to read to and write from the runtime. #[ink::chain_extension] pub trait RuntimeReadWrite { type ErrorCode = ReadWriteErrorCode; #[ink(extension = 1, returns_result = false)] fn read(key: &amp;[u8]) -&gt; Vec&lt;u8&gt;; #[ink(extension = 2)] fn read_small(key: &amp;[u8]) -&gt; Result&lt;(u32, [u8; 32]), ReadWriteError&gt;; #[ink(extension = 3, returns_result = false)] fn write(key: &amp;[u8], value: &amp;[u8]); #[ink(extension = 4, returns_result = false, handle_status = false)] fn access(key: &amp;[u8]) -&gt; Option&lt;Access&gt;; #[ink(extension = 5, handle_status = false)] fn unlock_access(key: &amp;[u8], access: Access) -&gt; Result&lt;(), UnlockAccessError&gt;; } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub enum ReadWriteErrorCode { InvalidKey, CannotWriteToKey, CannotReadFromKey, } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub enum ReadWriteError { ErrorCode(ReadWriteErrorCode), BufferTooSmall { required_bytes: u32 }, } impl From&lt;ReadWriteErrorCode&gt; for ReadWriteError { fn from(error_code: ReadWriteErrorCode) -&gt; Self { Self::ErrorCode(error_code) } } impl From&lt;scale::Error&gt; for ReadWriteError { fn from(_: scale::Error) -&gt; Self { panic!(&quot;encountered unexpected invalid SCALE encoding&quot;) } } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub struct UnlockAccessError { reason: String, } impl From&lt;scale::Error&gt; for UnlockAccessError { fn from(_: scale::Error) -&gt; Self { panic!(&quot;encountered unexpected invalid SCALE encoding&quot;) } } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub enum Access { ReadWrite, ReadOnly, WriteOnly, } impl ink_env::chain_extension::FromStatusCode for ReadWriteErrorCode { fn from_status_code(status_code: u32) -&gt; Result&lt;(), Self&gt; { match status_code { 0 =&gt; Ok(()), 1 =&gt; Err(Self::InvalidKey), 2 =&gt; Err(Self::CannotWriteToKey), 3 =&gt; Err(Self::CannotReadFromKey), _ =&gt; panic!(&quot;encountered unknown status code&quot;), } } } pub enum CustomEnvironment {} impl ink_env::Environment for CustomEnvironment { const MAX_EVENT_TOPICS: usize = &lt;ink_env::DefaultEnvironment as ink_env::Environment&gt;::MAX_EVENT_TOPICS; type AccountId = &lt;ink_env::DefaultEnvironment as ink_env::Environment&gt;::AccountId; type Balance = &lt;ink_env::DefaultEnvironment as ink_env::Environment&gt;::Balance; type Hash = &lt;ink_env::DefaultEnvironment as ink_env::Environment&gt;::Hash; type BlockNumber = &lt;ink_env::DefaultEnvironment as ink_env::Environment&gt;::BlockNumber; type Timestamp = &lt;ink_env::DefaultEnvironment as ink_env::Environment&gt;::Timestamp; type ChainExtension = RuntimeReadWrite; } }  "},{"title":"Technical Limitations​","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#technical-limitations","content":"Due to technical limitations it is not possible to refer to the ErrorCode associated type using Self::ErrorCode anywhere within the chain extension and its defined methods. Instead chain extension authors should directly use the error code type when required. This limitation might be lifted in future versions of ink!.It is not possible to declare other chain extension traits as super traits or super chain extensions of another. "},{"title":"#[ink(event)]","type":0,"sectionRef":"#","url":"macros-attributes/event","content":"#[ink(event)] Applicable on struct definitions. Defines an ink! event. A contract can define multiple such ink! events. See our section on Events for a detailed description and examples.","keywords":""},{"title":"#[ink(impl)]","type":0,"sectionRef":"#","url":"macros-attributes/impl","content":"","keywords":""},{"title":"Example​","type":1,"pageTitle":"#[ink(impl)]","url":"macros-attributes/impl#example","content":"An implementation block can be defined as a trait implementation for the ink! storage struct using the #[ink(impl)] annotation ‒ even if none of its interior items have any ink! specific attributes on them: use core::convert::TryFrom; use ink_lang_ir as ir; #[ink::contract] mod my_module { #[ink(storage)] pub struct MyStorage { /* storage fields */ } #[ink(impl)] impl MyStorage { fn my_method(&amp;self) -&gt; i32 { /* method implementation */ } } impl MyStorage { #[ink(constructor)] pub fn my_constructor() -&gt; Self { /* constructor implementation */ } #[ink(message)] pub fn my_message(&amp;self) { /* message implementation */ } } }  "},{"title":"#[ink(message)]","type":0,"sectionRef":"#","url":"macros-attributes/message","content":"","keywords":""},{"title":"Messages Return Value​","type":1,"pageTitle":"#[ink(message)]","url":"macros-attributes/message#messages-return-value","content":"The return value of a message needs to implement scale::Encode. It is notable that the collections under ink_storage ‒ such as e.g. Vec or HashMap ‒ don't implement scale::Encode. This means you can't just return a Vec from an ink! message. This restriction is intentional ‒ returning a complete data structure with a potentially unbounded content is an anti-pattern for smart contracts. Just think about the unpredicatble gas costs. If you really really need to return a data structure in its entirety then use the ones fromink_prelude (e.g. ink_prelude::vec::Vec). Those implement scale::Encode. "},{"title":"Example​","type":1,"pageTitle":"#[ink(message)]","url":"macros-attributes/message#example","content":"Given the Flipper contract definition above we add some #[ink(message)] definitions as follows: use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] pub fn new(initial_value: bool) -&gt; Self { Flipper { value: false } } /// Flips the current value. #[ink(message)] pub fn flip(&amp;mut self) { self.value = !self.value; } /// Returns the current value. #[ink(message)] pub fn get(&amp;self) -&gt; bool { self.value } } }  "},{"title":"#[ink(namespace = \"…\")]","type":0,"sectionRef":"#","url":"macros-attributes/namespace","content":"","keywords":""},{"title":"Example​","type":1,"pageTitle":"#[ink(namespace = \"…\")]","url":"macros-attributes/namespace#example","content":"#[ink(namespace = &quot;my_namespace&quot;)] impl MyTrait for MyStorage { #[ink(message)] fn my_message(&amp;self) {} }  This changes the resulting selectors of all the ink! messages and ink! constructors within the trait implementation. Thus allowing disambiguation between trait implementations with overlapping message or constructor names. "},{"title":"#[ink(selector = S:u32)]","type":0,"sectionRef":"#","url":"macros-attributes/selector","content":"","keywords":""},{"title":"Examples​","type":1,"pageTitle":"#[ink(selector = S:u32)]","url":"macros-attributes/selector#examples","content":"#[ink(message, selector = 0xC0DECAFE)] fn my_message_1(&amp;self) {} #[ink(message, selector = 42)] fn my_message_2(&amp;self) {}  … then the selector of my_message_1 is [0xC0, 0xDE, 0xCA, 0xFE] and the selector of my_message_2 is [0, 0, 0, 42]since setting the selector manually overrides the automatically generated selector. "},{"title":"Controlling the messages selector​","type":1,"pageTitle":"#[ink(selector = S:u32)]","url":"macros-attributes/selector#controlling-the-messages-selector","content":"Every ink! message and ink! constructor has a selector with which the message or constructor can be uniquely identified within the ink! smart contract. Non-unique message or constructor selector lead to a compile time error. These selectors are mainly used to drive the contract's dispatch upon calling it. An ink! smart contract author can control the selector of an ink! message or ink! constructor using the selector flag. An example is shown below: use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] #[ink(selector = 0xDEADBEEF)] // Works on constructors as well. pub fn new(initial_value: bool) -&gt; Self { Flipper { value: initial_value } } #[ink(message)] #[ink(selector = 0xCAFEBABE)] // You can either specify selector out-of-line. pub fn flip(&amp;mut self) { self.value = !self.value; } #[ink(message, selector = 0xC0DECAFE)] // ...or specify the selector inline. pub fn get(&amp;self) -&gt; bool { self.value } } }  "},{"title":"#[ink(storage)]","type":0,"sectionRef":"#","url":"macros-attributes/storage","content":"","keywords":""},{"title":"Example​","type":1,"pageTitle":"#[ink(storage)]","url":"macros-attributes/storage#example","content":"use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] pub fn construct() -&gt; Self { Flipper { value: false } } #[ink(message)] pub fn message(&amp;self) {} } }  "},{"title":"#[ink(payable)]","type":0,"sectionRef":"#","url":"macros-attributes/payable","content":"","keywords":""},{"title":"Example​","type":1,"pageTitle":"#[ink(payable)]","url":"macros-attributes/payable#example","content":"#[ink(message, payable)] pub fn pay_me(&amp;self) { let _transferred = self.env().transferred_balance(); }  See the examples/contract-transfer contract for a more extensive example. "},{"title":"Overview","type":0,"sectionRef":"#","url":"monthly-update/","content":"","keywords":""},{"title":"What is this?​","type":1,"pageTitle":"Overview","url":"monthly-update/#what-is-this","content":"Hey there reader 👋! This is meant to be a high-level overview of the changes that have taken place as part of Parity's Web Assembly (Wasm) smart contract efforts. These efforts include the ink!programming language, the pallet-contracts execution environment, the cargo-contractdevelopment tool, and the Contracts parachain. For anything UI related go check out thecontracts-ui repository. If these updates are too high-level for you you can always check out the release notes for the various projects: ink!pallet-contractscargo-contract If you're new here and aren't sure where to get started with ink! check out ourguided tutorial for beginners. This was inspired by the Polkadot Staking Progress Report ❤️. "},{"title":"#[ink(topic)]","type":0,"sectionRef":"#","url":"macros-attributes/topic","content":"","keywords":""},{"title":"Example​","type":1,"pageTitle":"#[ink(topic)]","url":"macros-attributes/topic#example","content":"#[ink(event)] pub struct Transferred { #[ink(topic)] from: Option&lt;AccountId&gt;, #[ink(topic)] to: Option&lt;AccountId&gt;, amount: Balance }  "},{"title":"March '22","type":0,"sectionRef":"#","url":"monthly-update/2022/03","content":"","keywords":""},{"title":"StackExchange Beta​","type":1,"pageTitle":"March '22","url":"monthly-update/2022/03#stackexchange-beta","content":"We are participating in the Beta of the Substrate StackExchange site! If this StackExchange site gains traction it will be made available to the general public. To reach this goal it's important to have the community engage there though. Head over to substrate.stackexchange.comto ask us any questions (there is an ink tag)! "},{"title":"ink! 3.0 🦑​","type":1,"pageTitle":"March '22","url":"monthly-update/2022/03#ink-30-","content":"The star of the show this month is the release of ink! 3.0: You can find the release notes here.We've also published a blog post with some more context:ink! 3.0: Parity’s Rust-Based Language for WASM Smart Contracts Gets a Major Update. The team has been working on this release for a while. If you're a developer you're probably aware of this thanks to the long list of release candidates (v3.0.0-rcX) we've pushed out in preparation for the stable 3.0 release. The main idea behind ink! 3.0 is that it's just Rust. The syntax is pretty much identical, and all the tooling you know and love, such as rust-analyzer and Clippy, just works. Some other included changes worth highlighting: Reduced contract sizes for better performance in a parachain context.Support for cross-contract calls, making it easier to write complex applications.Trait support, allowing for a more Rusty development experience. "},{"title":"cargo-contract 1.0​","type":1,"pageTitle":"March '22","url":"monthly-update/2022/03#cargo-contract-10","content":"Alongside the release of ink! 3.0 we're also releasing cargo-contract in its first stable version 1.0.cargo-contract is a handy developer tool for building, testing, and deploying ink! contracts. Some notable updates in this release include: Support for uploading and calling contracts on a chain with pallet-contracts.Linting rules for ink! contracts, giving developers warnings about common errors. "},{"title":"Delegate Call​","type":1,"pageTitle":"March '22","url":"monthly-update/2022/03#delegate-call","content":"Another update worth pointing out is the addition of delegate_call. What this allows is a way for contracts to forward a call they received to another contract. One use case for this is implementing a Proxy Upgrade Pattern for smart contracts. User ---- tx ---&gt; Proxy ----------&gt; Implementation_v0 | ------------&gt; Implementation_v1 | ------------&gt; Implementation_v2  This required some work in both pallet-contracts and ink!. Shoutout to the team over at Supercolony for driving the development here! We now have two example contracts for writing upgradeable contracts in ink!.See herefor a deeper explanation. "},{"title":"Workshop & Talk at EthDenver​","type":1,"pageTitle":"March '22","url":"monthly-update/2022/03#workshop--talk-at-ethdenver","content":"Hernando and Achim went to EthDenver to give a workshop and talk regarding ink! on the Substrate stage! The recording is available here. "},{"title":"April '22","type":0,"sectionRef":"#","url":"monthly-update/2022/04","content":"","keywords":""},{"title":"Releases 🆕​","type":1,"pageTitle":"April '22","url":"monthly-update/2022/04#releases-","content":"For ink! we released v3.0.1 with minor bugfixes. Besides that we made a number of improvements to our examples ‒ mostly to our upgradeable contracts examples. For cargo-contract we releasedv1.1.1 andv1.2.0with bug fixes, a new sub-command decode, and improved support for the call andinstantiate sub-commands. For tutorials, development and testing we recommend using oursubstrate-contracts-node. We issued the release v0.13.0, which is in sync with a recent Substrate master (see the release notes for the specific commit hash). Pre-built binaries for the release are available for Linux and Mac. "},{"title":"Community Badges 🙌​","type":1,"pageTitle":"April '22","url":"monthly-update/2022/04#community-badges-","content":"We've added two versions of a community badge. If you have a public repository with an ink! contract it would be awesome if you could add one of those! "},{"title":"Normal Design​","type":1,"pageTitle":"April '22","url":"monthly-update/2022/04#normal-design","content":" [![Built with ink!](https://raw.githubusercontent.com/paritytech/ink/master/.images/badge.svg)](https://github.com/paritytech/ink)  "},{"title":"Flat Design​","type":1,"pageTitle":"April '22","url":"monthly-update/2022/04#flat-design","content":" [![Built with ink!](https://raw.githubusercontent.com/paritytech/ink/master/.images/badge_flat.svg)](https://github.com/paritytech/ink)  "},{"title":"Team Retreat in Athens 🇬🇷​","type":1,"pageTitle":"April '22","url":"monthly-update/2022/04#team-retreat-in-athens-","content":"We ‒ the developers working on ink!, Substrate's pallet-contracts, and the Contracts UI ‒ went on a team retreat in April. We discussed our roadmap for the rest of this year, as well as some technical designs of how we want to implement e.g. XCM in ink!. We're normally working across different time zones, with some of us embracing the digital nomad lifestyle. Hence it was very productive to gather together for a week. We also did a little hackathon to do some dog-fooding: we've built a Dapp that makes use of all components by the above teams. We plan to open source it soon, stay tuned for that 😎. There's a lot on the horizon and we're enthusiastic about the rest of this year!  "},{"title":"Spanish Twitter Space 🐦​","type":1,"pageTitle":"April '22","url":"monthly-update/2022/04#spanish-twitter-space-","content":"Hernando was a guest at the spanish Polkadot Twitter Space. The space has been recorded:https://twitter.com/i/spaces/1MnGnkgmNdBJO. "},{"title":"StackExchange Public Beta​","type":1,"pageTitle":"April '22","url":"monthly-update/2022/04#stackexchange-public-beta","content":"The Substrate &amp; Polkadot StackExchange site has graduated from its private beta ‒ the site is now in public beta! This means that the site is now indexed by search engines and can be browser without any user account. If you have any questions regarding ink! or smart contracts on Substrate this is the place to be. "},{"title":"Canvas Update​","type":1,"pageTitle":"April '22","url":"monthly-update/2022/04#canvas-update","content":"You may know that we were working on a common good smart contracts parachain named Canvas. We've decided to put this project on hold. This gives us more room to make ink! and the pallet-contractsas competitive as possible, as well as help parachain teams include those. This is not to say that we'll never get back to Canvas, but as of right now we're no longer working on this project. "},{"title":"May '22","type":0,"sectionRef":"#","url":"monthly-update/2022/05","content":"","keywords":""},{"title":"Workshops & Talks 🎤​","type":1,"pageTitle":"May '22","url":"monthly-update/2022/05#workshops--talks-","content":"Michi gave a workshop for the ChainLink spring hackathon: YouTube link: Parity's ink! 101 | Write Smart Contracts for Substrate-Based Chains. "},{"title":"awesome-ink Repository 🤩​","type":1,"pageTitle":"May '22","url":"monthly-update/2022/05#awesome-ink-repository-","content":"Following popular demand we've createdhttps://github.com/paritytech/awesome-ink ‒ a curated list of awesome projects related to ink!. "},{"title":"Playground 🕹​","type":1,"pageTitle":"May '22","url":"monthly-update/2022/05#playground-","content":"The ink! playground has been published at https://ink-playground.substrate.io! It's handy for a couple of things. For example: You want to experiment with developing a contract without having to set up Rust locally.You run into an error and want to share a permalink to a code example, so that somebody can help you find the issue. This can be very helpful in case you post a question e.g. on ourStackExchange site. "},{"title":"Releases 🆕​","type":1,"pageTitle":"May '22","url":"monthly-update/2022/05#releases-","content":"For ink! we released v3.1.0, for cargo-contract we releasedv1.4.0. The release notes contain more details. "},{"title":"The URL to this portal changed​","type":1,"pageTitle":"May '22","url":"monthly-update/2022/05#the-url-to-this-portal-changed","content":"It's now available at https://ink.substrate.io. "},{"title":"Canvas Testnet ➜ Contracts Testnet​","type":1,"pageTitle":"May '22","url":"monthly-update/2022/05#canvas-testnet--contracts-testnet","content":"We've renamed our &quot;Canvas&quot; testnet to &quot;Contracts&quot; testnet. More information about the background for this can be found inlast months digest. "},{"title":"Why WebAssembly for Smart Contracts?","type":0,"sectionRef":"#","url":"why-webassembly-for-smart-contracts","content":"Why WebAssembly for Smart Contracts? High performance: Wasm is high performance — it’s built to be as close to native machine code as possible while still being platform independent.Small size: It facilitates small binaries to ship over the internet to devices with potentially slow internet connection. This is a great fit for the space-constrainted blockchain world.General VM &amp; bytecode: It was developed so that code can be deployed in any browser with the same result. Contrary to the EVM it was not developed towards a very specific use case, this has the benefit of a lot of tooling being available and large companies putting a lot of resources into furthering Wasm development.Efficient JIT execution: 64 and 32-bit integer operation support that maps one-to-one with CPU instructions.Minimalistic: Formal spec that fits on a single page.Deterministic execution: Wasm is easily made deterministic by removing floating point operations, which is necessary for consensus algorithms.Open Standards &gt; Custom Solutions: Wasm is a standard for web browsers developed by W3C workgroup that includes Google, Mozilla, and others. There’s been many years of work put into Wasm, both by compiler and standardisation teams.Many languages available: Wasm expands the family of languages available to smart contract developers to include Rust, C/C++, C#, Typescript, Haxe, and Kotlin. This means you can write smart contracts in whichever language you’re familiar with, though we’re partial to Rust due to its lack of runtime overhead and inherent security properties.Memory-safe, sandboxed, and platform-independent.LLVM support: Supported by the LLVM compiler infrastructure project, meaning that Wasm benefits from over a decade of LLVM’s compiler optimisation.Large companies involved: Continually developed by major companies such as Google, Apple, Microsoft, Mozilla, and Facebook.","keywords":""},{"title":"Why Rust for Smart Contracts?","type":0,"sectionRef":"#","url":"why-rust-for-smart-contracts","content":"Why Rust for Smart Contracts? ink! chooses not to invent a new programming language, but rather adapt a subset of Rust to serve our purpose. If this doesn't already convince you, you find many more good reasons here: Rust is an ideal smart contract language: It is type safe, memory safe, and free of undefined behaviors. It generates small binaries because it doesn’t include extra bloat, like a garbage collector, and advanced optimizations and tree shaking remove dead code. Through compiler flags, Rust can automatically protect against integer overflow.Rust ecosystem: You gain from all of support available to the Rust ecosystem for free. As the language develops, ink! will automatically gain access to new features and functionality, improving how you can write smart contracts in the future.Tooling: Because ink! follows Rust standards, tools like rustfmt, clippy and rust-analyzer already work out of the box. Same goes for code formatting and syntax highlighting in most modern text editors. Also Rust has an integrated test and benchmark runner,No overhead: Minimal runtime.Safe &amp; Efficient: Zero-cost &amp; safe abstractions.Productive: Cargo + crates.io Ecosystem.1st class Wasm: Rust provides the first class support for the WebAssembly.Small Size: In the space-constrained blockchain world size is important. The Rust compiler is a great help for that, since it reorders struct fields in order to make each type as small as possible. Thus Rust data structures are very compact, in many cases even more compact than in C.","keywords":""}]