(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{84:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return b})),n.d(t,"rightToc",(function(){return o})),n.d(t,"default",(function(){return s}));var a=n(2),i=n(6),r=(n(0),n(92)),c={title:"Overview",slug:"/ink-macros-attributes"},b={unversionedId:"ink-macros/overview",id:"ink-macros/overview",isDocsHomePage:!1,title:"Overview",description:"ink! Macros & Attributes",source:"@site/docs/ink-macros/overview.md",slug:"/ink-macros-attributes",permalink:"/ink-docs/ink-macros-attributes",editUrl:"https://github.com/ink-docs/edit/master/docs/ink-macros/overview.md",version:"current",sidebar:"reference",previous:{title:"Off-chain Testing",permalink:"/ink-docs/basics/off-chain-testing"},next:{title:"Overview",permalink:"/ink-docs/datastructures/custom"}},o=[{value:"ink! Macros &amp; Attributes",id:"ink-macros--attributes",children:[]},{value:"Merging of ink! Attributes",id:"merging-of-ink-attributes",children:[{value:"Entry Point",id:"entry-point",children:[]},{value:"Trait Definitions",id:"trait-definitions",children:[]},{value:"Off-chain Testing",id:"off-chain-testing",children:[]}]}],l={rightToc:o};function s(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"ink-macros--attributes"},"ink! Macros & Attributes"),Object(r.b)("p",null,"All of these ink! attributes are available to specify inside an ink! module.\nAn ink! module is the module that is flagged by ",Object(r.b)("inlineCode",{parentName:"p"},"#[ink::contract]")," containing all the ink! definitions:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"use ink_lang as ink;\n\n#[ink::contract]\nmod erc20 {\n    #[ink(storage)]\n    pub struct Erc20 { ... }\n\n    impl Erc20 {\n        #[ink(constructor)]\n        pub fn new(initial_supply: Balance) -> Self { .. }\n\n        #[ink(constructor)]\n        pub fn total_supply(&self) -> Balance { .. }\n\n        // etc. ...\n    }\n}\n")),Object(r.b)("p",null,"We won't be going into the details for any of those but will briefly present the entire set of ink! specific attributes below:"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",Object(a.a)({parentName:"tr"},{align:"left"}),"Attribute"),Object(r.b)("th",Object(a.a)({parentName:"tr"},{align:"left"}),"Where Applicable"),Object(r.b)("th",Object(a.a)({parentName:"tr"},{align:"left"}),"Description"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},"#[ink(storage)]")),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"On ",Object(r.b)("inlineCode",{parentName:"td"},"struct")," definitions."),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Defines the ink! storage struct. There can only be one ink! storage definition per contract.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},"#[ink(event)]")),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"On ",Object(r.b)("inlineCode",{parentName:"td"},"struct")," definitions."),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Defines an ink! event. A contract can define multiple such ink! events.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},"#[ink(anonymous)]")," ",Object(r.b)("strong",{parentName:"td"},"new")),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Applicable to ink! events."),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Tells the ink! codegen to treat the ink! event as anonymous which omits the event signature as topic upon emitting. Very similar to anonymous events in Solidity.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},"#[ink(topic)]")),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Applicate on ink! event field."),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Tells the ink! codegen to provide a topic hash for the given field. Every ink! event can only have a limited number of such topic field. Similar semantics as to indexed event arguments in Solidity.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},"#[ink(message)]")),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Applicable to methods."),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Flags a method for the ink! storage struct as message making it available to the API for calling the contract.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},"#[ink(constructor)]")),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Applicable to method."),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Flags a method for the ink! storage struct as constructor making it available to the API for instantiating the contract.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},"#[ink(payable)]")," ",Object(r.b)("strong",{parentName:"td"},"new")),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Applicable to ink! messages."),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Allows receiving value as part of the call of the ink! message. ink! constructors are implicitly payable.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},'#[ink(selector = "..")]')," ",Object(r.b)("strong",{parentName:"td"},"new")),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Applicable to ink! messages and ink! constructors."),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Specifies a concrete dispatch selector for the flagged entity. This allows a contract author to precisely control the selectors of their APIs making it possible to rename their API without breakage.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},'#[ink(namespace = "..")]')," ",Object(r.b)("strong",{parentName:"td"},"new")),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Applicable to ink! trait implementation blocks."),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Changes the resulting selectors of all the ink! messages and ink! constructors within the trait implementation. Allows to disambiguate between trait implementations with overlapping message or constructor names. Use only with great care and consideration!")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},"#[ink(implementation)]")," ",Object(r.b)("strong",{parentName:"td"},"new")),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Applicable to ink! implementation blocks."),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Tells the ink! codegen that some implementation block shall be granted access to ink! internals even without it containing any ink! messages or ink! constructors.")))),Object(r.b)("h2",{id:"merging-of-ink-attributes"},"Merging of ink! Attributes"),Object(r.b)("p",null,"It is possible to merge attributes that share a common flagged entity.\nThe example below demonstrates this for a payable message with a custom selector."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),'#[ink(message)]\n#[ink(payable)]\n#[ink(selector = "0xCAFEBABE")]\npub fn transfer(&mut self, from: AccountId, to: AccountId, value: Balance) -> Result<(), Error> {\n    // actual implementation\n}\n')),Object(r.b)("p",null,"We can also write the above ink! message definition in the following way:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),'#[ink(message, payable, selector = "0xCAFEBABE")]\npub fn transfer(&mut self, from: AccountId, to: AccountId, value: Balance) -> Result<(), Error> {\n    // actual implementation\n}\n')),Object(r.b)("h3",{id:"entry-point"},"Entry Point"),Object(r.b)("p",null,"In a module annotated with ",Object(r.b)("inlineCode",{parentName:"p"},"#[ink::contract]")," these attributes are available:"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",Object(a.a)({parentName:"tr"},{align:"left"}),"Attribute"),Object(r.b)("th",Object(a.a)({parentName:"tr"},{align:"left"}),"Where Applicable"),Object(r.b)("th",Object(a.a)({parentName:"tr"},{align:"left"}),"Description"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},"#[ink(storage)]")),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"On ",Object(r.b)("inlineCode",{parentName:"td"},"struct")," definitions."),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Defines the ink! storage struct. There can only be one ink! storage definition per contract.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},"#[ink(event)]")),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"On ",Object(r.b)("inlineCode",{parentName:"td"},"struct")," definitions."),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Defines an ink! event. A contract can define multiple such ink! events.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},"#[ink(anonymous)]")),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Applicable to ink! events."),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Tells the ink! codegen to treat the ink! event as anonymous which omits the event signature as topic upon emitting. Very similar to anonymous events in Solidity.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},"#[ink(topic)]")),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Applicate on ink! event field."),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Tells the ink! codegen to provide a topic hash for the given field. Every ink! event can only have a limited number of such topic field. Similar semantics as to indexed event arguments in Solidity.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},"#[ink(message)]")),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Applicable to methods."),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Flags a method for the ink! storage struct as message making it available to the API for calling the contract.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},"#[ink(constructor)]")),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Applicable to method."),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Flags a method for the ink! storage struct as constructor making it available to the API for instantiating the contract.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},"#[ink(payable)]")),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Applicable to ink! messages."),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Allows receiving value as part of the call of the ink! message. ink! constructors are implicitly payable.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},'#[ink(selector = "..")]')),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Applicable to ink! messages and ink! constructors."),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Specifies a concrete dispatch selector for the flagged entity. This allows a contract author to precisely control the selectors of their APIs making it possible to rename their API without breakage.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},'#[ink(namespace = "..")]')),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Applicable to ink! trait implementation blocks."),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Changes the resulting selectors of all the ink! messages and ink! constructors within the trait implementation. Allows to disambiguate between trait implementations with overlapping message or constructor names. Use only with great care and consideration!")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},"#[ink(implementation)]")),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Applicable to ink! implementation blocks."),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Tells the ink! codegen that some implementation block shall be granted access to ink! internals even without it containing any ink! messages or ink! constructors.")))),Object(r.b)("p",null,"See ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://paritytech.github.io/ink/ink_lang/attr.contract.html"}),"here")," for a more detailed description of those and also for details on the ",Object(r.b)("inlineCode",{parentName:"p"},"#[ink::contract]")," macro."),Object(r.b)("h3",{id:"trait-definitions"},"Trait Definitions"),Object(r.b)("p",null,"Use",Object(r.b)("inlineCode",{parentName:"p"},"#[ink::trait_definition]")," to define your very own trait definitions that are then implementable by ink! smart contracts.\nSee e.g. the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/paritytech/ink/blob/master/examples/trait-erc20/lib.rs#L49-L51"}),Object(r.b)("inlineCode",{parentName:"a"},"examples/trait-erc20"))," contract on how to utilize it or ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://paritytech.github.io/ink/ink_lang/attr.trait_definition.html"}),"the documentation")," for details."),Object(r.b)("p",null,"TODO link other section"),Object(r.b)("h3",{id:"off-chain-testing"},"Off-chain Testing"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"#[ink::test]")," proc. macro enables off-chain testing. See e.g. the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/paritytech/ink/blob/master/examples/erc20/lib.rs#L278-L280"}),Object(r.b)("inlineCode",{parentName:"a"},"examples/erc20"))," contract on how to utilize those or ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://paritytech.github.io/ink/ink_lang/attr.test.html"}),"the documentation")," for details."))}s.isMDXComponent=!0},92:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return O}));var a=n(0),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function b(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=i.a.createContext({}),s=function(e){var t=i.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):b(b({},t),e)),n},p=function(e){var t=s(e.components);return i.a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},d=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,c=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),p=s(n),d=a,O=p["".concat(c,".").concat(d)]||p[d]||m[d]||r;return n?i.a.createElement(O,b(b({ref:t},l),{},{components:n})):i.a.createElement(O,b({ref:t},l))}));function O(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,c=new Array(r);c[0]=d;var b={};for(var o in t)hasOwnProperty.call(t,o)&&(b[o]=t[o]);b.originalType=e,b.mdxType="string"==typeof e?e:a,c[1]=b;for(var l=2;l<r;l++)c[l]=n[l];return i.a.createElement.apply(null,c)}return i.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);