"use strict";(self.webpackChunkink_docs=self.webpackChunkink_docs||[]).push([[2812],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>g});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(t),m=r,g=p["".concat(l,".").concat(m)]||p[m]||d[m]||o;return t?a.createElement(g,i(i({ref:n},u),{},{components:t})):a.createElement(g,i({ref:n},u))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},171:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=t(7462),r=(t(7294),t(3905));const o={title:"Almacenando Valores",slug:"/basics/storing-values",hide_title:!0},i=void 0,s={unversionedId:"basics/storing-values",id:"basics/storing-values",title:"Almacenando Valores",description:"As\xed es como se almacenan valores simples en el storage:",source:"@site/i18n/es/docusaurus-plugin-content-docs/current/basics/storing-values.md",sourceDirName:"basics",slug:"/basics/storing-values",permalink:"/es/basics/storing-values",draft:!1,editUrl:"https://github.com/paritytech/ink-docs/edit/master/docs/basics/storing-values.md",tags:[],version:"current",frontMatter:{title:"Almacenando Valores",slug:"/basics/storing-values",hide_title:!0},sidebar:"reference",previous:{title:"Plantilla de un Contrato",permalink:"/es/basics/contract-template"},next:{title:"Leer Valores del Storage",permalink:"/es/basics/leer-valores-del-storage"}},l={},c=[{value:"Tipos Soportados",id:"tipos-soportados",level:2},{value:"Use of enum",id:"use-of-enum",level:2},{value:"Inicializar Storage en Constructores",id:"inicializar-storage-en-constructores",level:2}],u={toc:c};function p(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("img",{src:"/img/title/storage.svg",className:"titlePic"}),(0,r.kt)("h1",{id:"almacenando-valores"},"Almacenando Valores"),(0,r.kt)("p",null,"As\xed es como se almacenan valores simples en el ",(0,r.kt)("inlineCode",{parentName:"p"},"storage"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(storage)]\npub struct MyContract {\n    // Store a bool\n    my_bool: bool,\n    // Store some number\n    my_number: u32,\n}\n/* --snip-- */\n")),(0,r.kt)("h2",{id:"tipos-soportados"},"Tipos Soportados"),(0,r.kt)("p",null,"Los contratos de Substrate pueden almacenar tipos que sean codificables y decodificables con ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/parity-codec"},"Parity Codec"),"\nque incluye la mayor\xeda de los tipos de datos comunes de Rust, como ",(0,r.kt)("inlineCode",{parentName:"p"},"bool"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"u{8,16,32,64,128}"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"i{8,16,32,64,128}"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),", tuplas, y arrays."),(0,r.kt)("p",null,"ink! proporciona tipos espec\xedficos como ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountId"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Balance"),", y ",(0,r.kt)("inlineCode",{parentName:"p"},"Hash")," para smart contracts como si fuesen tipos primitivos."),(0,r.kt)("p",null,"ink! tambi\xe9n proporciona el tipo de storage ",(0,r.kt)("inlineCode",{parentName:"p"},"Mapping"),". Puedes leer m\xe1s sobre este tipo ",(0,r.kt)("a",{parentName:"p",href:"/datastructures/mapping"},"aqu\xed"),"."),(0,r.kt)("p",null,"Aqu\xed tienes un ejemplo de como puedes almacenar un ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountId")," y ",(0,r.kt)("inlineCode",{parentName:"p"},"Balance"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink::contract]\nmod MyContract {\n\n    // Our struct will use those default ink! types\n    #[ink(storage)]\n    pub struct MyContract {\n        // Store some AccountId\n        my_account: AccountId,\n        // Store some Balance\n        my_balance: Balance,\n    }\n    /* --snip-- */\n}\n")),(0,r.kt)("p",null,"A continuaci\xf3n un ejemplo de una estructura almacenando valores ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),"\ny ",(0,r.kt)("inlineCode",{parentName:"p"},"Hash"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct Auction {\n     /// Nombre del auction\n     name: String,\n     /// Un hash que identifica el asunto del auction\n     subject: Hash,\n     /// Estado del auction\n     status: Status, // Enum: Uso de Enum se muestra m\xe1s adelante\n     /// Un candle auction puede no tener ganador.\n     /// Si el auction ha terminado, significa que el ganador ha sido elegido.\n     finalized: bool,\n     /// vector\n     vector: Vec<u8>,\n}\n")),(0,r.kt)("h2",{id:"use-of-enum"},"Use of enum"),(0,r.kt)("p",null,"Enum puede ser usado como el tipo de un valor dentro de un ",(0,r.kt)("inlineCode",{parentName:"p"},"struct")," como se ha mostrado antes en ",(0,r.kt)("inlineCode",{parentName:"p"},"struct Auction"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub enum Status {\n    /// El auction a\xfan no ha comenzado.\n    NotStarted,\n    /// El auction se encuentra en la parte inicial, acumulando pujas iniciales.\n    OpeningPeriod,\n    /// Nos encontramos en la parte final del auction, tomamos snapshots\n    /// de las pujas ganadoras.\n    EndingPeriod,\n}\n")),(0,r.kt)("p",null,"Los valores de un enum deben ser referenciados como ",(0,r.kt)("inlineCode",{parentName:"p"},"Status::OpeningPeriod"),"."),(0,r.kt)("h2",{id:"inicializar-storage-en-constructores"},"Inicializar Storage en Constructores"),(0,r.kt)("p",null,"Constructores es c\xf3mo se inicializan los valores\nCada ink! smart contract debe tener un constructor que se ejecuta una vez cuando el contrato es creado. Los ink! smart contracts pueden tener m\xfaltiples constructores:"),(0,r.kt)("p",null,"Tenga en cuenta que si tiene un contrato cuyo almacenamiento contiene ",(0,r.kt)("inlineCode",{parentName:"p"},"Mapping")," tambi\xe9n puedes utilizar\n",(0,r.kt)("inlineCode",{parentName:"p"},"ink_lang::utils::initialize_contract")," en tu constructor. Mira la\n",(0,r.kt)("a",{parentName:"p",href:"/datastructures/mapping"},"documentaci\xf3n de ",(0,r.kt)("inlineCode",{parentName:"a"},"Mapping"))," para m\xe1s detalles."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink::contract]\nmod mycontract {\n\n    #[ink(storage)]\n    pub struct MyContract {\n        number: u32,\n    }\n\n    impl MyContract {\n        /// Constructor that initializes the `u32` value to the given `init_value`.\n        #[ink(constructor)]\n        pub fn new(init_value: u32) -> Self {\n            Self {\n                number: init_value,\n            }\n        }\n\n        /// Constructor that initializes the `u32` value to the `u32` default.\n        #[ink(constructor)]\n        pub fn default() -> Self {\n            Self {\n                number: Default::default(),\n            }\n        }\n    /* --snip-- */\n    }\n}\n")))}p.isMDXComponent=!0}}]);