"use strict";(self.webpackChunkink_docs=self.webpackChunkink_docs||[]).push([[773],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>f});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),c=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(i.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),d=r,f=p["".concat(i,".").concat(d)]||p[d]||m[d]||o;return n?a.createElement(f,s(s({ref:t},u),{},{components:n})):a.createElement(f,s({ref:t},u))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=d;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l[p]="string"==typeof e?e:r,s[1]=l;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1752:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const o={title:"Testing del Contrato",slug:"/basics/contract-testing"},s=void 0,l={unversionedId:"basics/testing",id:"version-4.0.0-alpha.1/basics/testing",title:"Testing del Contrato",description:"Unit Tests",source:"@site/i18n/es/docusaurus-plugin-content-docs/version-4.0.0-alpha.1/basics/testing.md",sourceDirName:"basics",slug:"/basics/contract-testing",permalink:"/es/4.0.0-alpha.1/basics/contract-testing",draft:!1,editUrl:"https://github.com/paritytech/ink-docs/edit/master/versioned_docs/version-4.0.0-alpha.1/basics/testing.md",tags:[],version:"4.0.0-alpha.1",frontMatter:{title:"Testing del Contrato",slug:"/basics/contract-testing"},sidebar:"reference",previous:{title:"Metadata",permalink:"/es/4.0.0-alpha.1/metadata"},next:{title:"Contract Debugging",permalink:"/es/4.0.0-alpha.1/basics/contract-debugging"}},i={},c=[{value:"Unit Tests",id:"unit-tests",level:2},{value:"Off-chain Testing",id:"off-chain-testing",level:2},{value:"\xbfC\xf3mo saber si su test requiere el entorno off-chain?",id:"c\xf3mo-saber-si-su-test-requiere-el-entorno-off-chain",level:2},{value:"Ejemplo",id:"ejemplo",level:2},{value:"On-chain Testing",id:"on-chain-testing",level:2}],u={toc:c};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"unit-tests"},"Unit Tests"),(0,r.kt)("p",null,"El testing de los contractos off-chain se hace mediante ",(0,r.kt)("inlineCode",{parentName:"p"},"cargo test")," y los usuarios pueden simplemente utilizar las rutinas est\xe1ndar para\ncrear m\xf3dulos de unit test dentro del projecto de ink!:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn my_test() { ... }\n}\n")),(0,r.kt)("p",null,"Se pueden crear instancias de test de los contratos as\xed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let contract = MyContract::my_constructor(a, b);\n")),(0,r.kt)("p",null,"Los mensajes se pueden llamar simplemente en la instancia devuelta como si ",(0,r.kt)("inlineCode",{parentName:"p"},"MyContract::my_constructor")," devolviese\nuna instancia ",(0,r.kt)("inlineCode",{parentName:"p"},"Self"),"."),(0,r.kt)("p",null,"Vea el ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/blob/master/examples/flipper/lib.rs"},"ejemplo flipper"),"."),(0,r.kt)("h2",{id:"off-chain-testing"},"Off-chain Testing"),(0,r.kt)("p",null,"Los ink! smart contracts se pueden compilar de diversas maneras.\nExisten 2 principales modelos de compilaci\xf3n utilizando"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"modo on-chain: ",(0,r.kt)("inlineCode",{parentName:"li"},"no_std")," + WebAssembly as target"),(0,r.kt)("li",{parentName:"ul"},"modo off-chain: ",(0,r.kt)("inlineCode",{parentName:"li"},"std"))),(0,r.kt)("p",null,"Generalmente utilizamos el modo on-chain para el despliegue del smart contract mientras que\nutilizamos el modo off-chain para el testing de smart contracts utilizando el entorno off-chain\nproporcionado por el crate ",(0,r.kt)("inlineCode",{parentName:"p"},"ink_env"),"."),(0,r.kt)("p",null,"La proc. macro ",(0,r.kt)("inlineCode",{parentName:"p"},"#[ink::test]")," permite off-chain testing m\xe1s elaborado."),(0,r.kt)("p",null,"Si anotas un test con este atributo se ejecutara en un entorno simulado,\nsimilar a como se ejecutar\xeda on-chain.\nEntonces tienes un control detallado sobre c\xf3mo llamar al contrato;\npor ejemplo puedes influir en el avance del bloque, el valor transferido al mismo,\npor qu\xe9 cuenta se llama, con qu\xe9 almacenamiento se ejecuta, etc."),(0,r.kt)("p",null,"Vea el contrato ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/blob/master/examples/erc20/lib.rs"},(0,r.kt)("inlineCode",{parentName:"a"},"examples/erc20"))," csobre como utilizarlo o ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/ink_lang/3.3.1/ink_lang/attr.test.html"},"la documentaci\xf3n")," para m\xe1s detalles."),(0,r.kt)("p",null,"En este momento hay algunas limitaciones conocidas para nuestro entorno off-chain y estamos trabajando\nen hacer que el comportamiento sea lo m\xe1s cercano posible a un entorno de una red real."),(0,r.kt)("p",null,"Define un unit test que utilice las capacidades del ink! testing off-chain."),(0,r.kt)("p",null,"Si tu unit test no requiere de la existencia de un entorno off-chain esta bien no\nutilizar esta macro ya que tiene algunos gastos generales con el test."),(0,r.kt)("p",null,"Date cuenta que esta macro no es necesaria para ejecutar los unit tests que requieren\nlas capacidades del ink! testing off-chain pero simplemente mejora la legibilidad del c\xf3digo."),(0,r.kt)("h2",{id:"c\xf3mo-saber-si-su-test-requiere-el-entorno-off-chain"},"\xbfC\xf3mo saber si su test requiere el entorno off-chain?"),(0,r.kt)("p",null,"Normalmente si el test utiliza recursivamente o invoca algunos metodos del contrato que\nllaman a un metodo definido en ",(0,r.kt)("inlineCode",{parentName:"p"},"self.env()")," o ",(0,r.kt)("inlineCode",{parentName:"p"},"Self::env()"),"."),(0,r.kt)("p",null,"Un ejemplo es el siguiente:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let caller: AccountId = self.env().caller();\n")),(0,r.kt)("h2",{id:"ejemplo"},"Ejemplo"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use ink_lang as ink;\n\n#[cfg(test)]\nmod tests {\n    // Conventional unit test that works with assertions.\n    #[ink::test]\n    fn test1() {\n        // test code comes here as usual\n    }\n\n    // Unit test convencional que devuelve alg\xfan Result.\n    // El c\xf3digo del test puede utilizar el operador-`?`.\n    #[ink::test]\n    fn test2() -> Result<(), ink_env::Error> {\n        // El c\xf3digo del test que devuelve un tipo Rust Result\n    }\n}\n")),(0,r.kt)("h2",{id:"on-chain-testing"},"On-chain Testing"),(0,r.kt)("p",null,"La manera m\xe1s sencilla de hacer un test on-chain es\n",(0,r.kt)("a",{parentName:"p",href:"/getting-started/running-substrate"},"ejecutar un nodo substrate local"),",\ndesplegar tu contrato alli e interactuar con el."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use ink_lang as ink;\n\n#[ink::contract]\nmod greeter {\n    #[ink(storage)]\n    pub struct Greeter;\n\n    impl Greeter {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            let caller = Self::env().caller();\n            let message = format!("thanks for instantiation {:?}", caller);\n            ink_env::debug_println(&message);\n            Greeter {}\n        }\n\n        #[ink(message, payable)]\n        pub fn fund(&mut self) {\n            let caller = self.env().caller();\n            let value = self.env().transferred_balance();\n            let message = format!("thanks for the funding of {:?} from {:?}", value, caller);\n            ink_env::debug_println(&message);\n        }\n    }\n}\n')))}p.isMDXComponent=!0}}]);