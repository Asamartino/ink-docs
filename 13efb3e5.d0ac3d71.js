(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{105:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return f}));var r=t(0),a=t.n(r);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=a.a.createContext({}),u=function(e){var n=a.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=u(e.components);return a.a.createElement(l.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},b=a.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=u(t),b=r,f=p["".concat(s,".").concat(b)]||p[b]||m[b]||i;return t?a.a.createElement(f,o(o({ref:n},l),{},{components:t})):a.a.createElement(f,o({ref:n},l))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,s=new Array(i);s[0]=b;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var l=2;l<i;l++)s[l]=t[l];return a.a.createElement.apply(null,s)}return a.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"},54:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return s})),t.d(n,"metadata",(function(){return o})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return u}));var r=t(2),a=t(6),i=(t(0),t(105)),s={title:"#[ink(message)]",slug:"/ink-macros-attributes/message"},o={unversionedId:"ink-macros/message",id:"ink-macros/message",isDocsHomePage:!1,title:"#[ink(message)]",description:"Applicable to methods.",source:"@site/docs/ink-macros/message.md",slug:"/ink-macros-attributes/message",permalink:"/ink-docs/ink-macros-attributes/message",editUrl:"https://github.com/ink-docs/edit/master/docs/ink-macros/message.md",version:"current",sidebar:"reference",previous:{title:"#[ink(impl)]",permalink:"/ink-docs/ink-macros-attributes/impl"},next:{title:'#[ink(namespace = "\u2026")]',permalink:"/ink-docs/ink-macros-attributes/namespace"}},c=[{value:"Example",id:"example",children:[]},{value:"Messages Return Value",id:"messages-return-value",children:[]}],l={rightToc:c};function u(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Applicable to methods."),Object(i.b)("p",null,"Flags a method for the ink! storage struct as message making it available to the API for calling the contract. "),Object(i.b)("p",null,"Note that all public functions must use the ",Object(i.b)("inlineCode",{parentName:"p"},"#[ink(message)]")," attribute"),Object(i.b)("p",null,"There must be at least one ",Object(i.b)("inlineCode",{parentName:"p"},"#[ink(message)]")," defined method."),Object(i.b)("p",null,"Methods flagged with ",Object(i.b)("inlineCode",{parentName:"p"},"#[ink(message)]")," are special in that they are dispatchable\nupon contract invocation. The set of ink! messages defined for an ink! smart contract\ndefine its API surface with which users are allowed to interact."),Object(i.b)("p",null,"An ink! smart contract can have multiple such ink! messages defined."),Object(i.b)("p",null,"An ink! message with a ",Object(i.b)("inlineCode",{parentName:"p"},"&self")," receiver may only read state whereas an ink! message\nwith a ",Object(i.b)("inlineCode",{parentName:"p"},"&mut self")," receiver may mutate the contract's storage."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-rust"}),"#[ink(message)]\npub fn purely_reading(&self, from: AccountId) {\n    // actual implementation\n}\n\n#[ink(message)]\npub fn mutates_storage(&mut self, from: AccountId) {\n    // actual implementation\n}\n")),Object(i.b)("h2",{id:"example"},"Example"),Object(i.b)("p",null,"Given the ",Object(i.b)("inlineCode",{parentName:"p"},"Flipper")," contract definition above we add some ",Object(i.b)("inlineCode",{parentName:"p"},"#[ink(message)]")," definitions\nas follows:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-rust"}),"use ink_lang as ink;\n\n#[ink::contract]\nmod flipper {\n    #[ink(storage)]\n    pub struct Flipper {\n        value: bool,\n    }\n\n    impl Flipper {\n\n        #[ink(constructor)]\n        pub fn new(initial_value: bool) -> Self {\n            Flipper { value: false }\n        }\n\n        /// Flips the current value.\n        #[ink(message)]\n        pub fn flip(&mut self) {\n            self.value = !self.value;\n        }\n\n        /// Returns the current value.\n        #[ink(message)]\n        pub fn get(&self) -> bool {\n            self.value\n        }\n    }\n}\n")),Object(i.b)("h2",{id:"messages-return-value"},"Messages Return Value"),Object(i.b)("p",null,"TODO"))}u.isMDXComponent=!0}}]);