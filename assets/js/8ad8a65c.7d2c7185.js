"use strict";(self.webpackChunkink_docs=self.webpackChunkink_docs||[]).push([[9848],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return h}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),u=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=u(t),h=r,f=m["".concat(s,".").concat(h)]||m[h]||p[h]||o;return t?a.createElement(f,i(i({ref:n},c),{},{components:t})):a.createElement(f,i({ref:n},c))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var u=2;u<o;u++)i[u]=t[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},262:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return u},toc:function(){return c},default:function(){return m}});var a=t(7462),r=t(3366),o=(t(7294),t(3905)),i=["components"],l={title:"Working with Datastructures",slug:"/datastructures/hashmap"},s=void 0,u={unversionedId:"datastructures/hashmap",id:"datastructures/hashmap",title:"Working with Datastructures",description:"In this section we want to demonstrate how to work with ink! datastructures.",source:"@site/docs/datastructures/hashmap.md",sourceDirName:"datastructures",slug:"/datastructures/hashmap",permalink:"/ink-docs/datastructures/hashmap",editUrl:"https://github.com/ink-docs/edit/master/docs/datastructures/hashmap.md",tags:[],version:"current",frontMatter:{title:"Working with Datastructures",slug:"/datastructures/hashmap"},sidebar:"reference",previous:{title:"Overview",permalink:"/ink-docs/datastructures/overview"},next:{title:"Spread vs. Packed",permalink:"/ink-docs/datastructures/spread-packed-layout"}},c=[{value:"Storage HashMap API",id:"storage-hashmap-api",children:[],level:2},{value:"Initializing a HashMap",id:"initializing-a-hashmap",children:[],level:2},{value:"Contract Caller",id:"contract-caller",children:[],level:2},{value:"Modifying a HashMap",id:"modifying-a-hashmap",children:[],level:2},{value:"Entry API",id:"entry-api",children:[],level:2}],p={toc:c};function m(e){var n=e.components,t=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"In this section we want to demonstrate how to work with ink! datastructures.\nWe will do this using the example of our ",(0,o.kt)("inlineCode",{parentName:"p"},"HashMap"),", which allows you to store items in a key-value mapping."),(0,o.kt)("p",null,"Here is an example of a mapping from a user to a number:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(storage)]\npub struct MyContract {\n    // Store a mapping from AccountIds to a u32\n    my_number_map: ink_storage::collections::HashMap<AccountId, u32>,\n}\n")),(0,o.kt)("p",null,'This means that for a given key, you can store a unique instance of a value type. In this case, each "user" gets their own number, and we can build logic so that only they can modify their own numbers.'),(0,o.kt)("h2",{id:"storage-hashmap-api"},"Storage HashMap API"),(0,o.kt)("p",null,"You can find the full HashMap API in the ",(0,o.kt)("a",{parentName:"p",href:"https://paritytech.github.io/ink/ink_storage/collections/hashmap/index.html"},"crate documentation")," part of ink!."),(0,o.kt)("p",null,"Here are some of the most common functions you might use:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"/// Inserts a key-value pair into the map.\n\n/// Returns the previous value associated with the same key if any.\n/// If the map did not have this key present, `None` is returned.\npub fn insert(&mut self, key: K, new_value: V) -> Option<V> {/* --snip-- */}\n\n/// Removes the key/value pair from the map associated with the given key.\n///\n/// - Returns the removed value if any.\npub fn take<Q>(&mut self, key: &Q) -> Option<V> {/* --snip-- */}\n\n/// Returns a shared reference to the value corresponding to the key.\n///\n/// The key may be any borrowed form of the map's key type,\n/// but `Hash` and `Eq` on the borrowed form must match those for the key type.\npub fn get<Q>(&self, key: &Q) -> Option<&V> {/* --snip-- */}\n\n/// Returns a mutable reference to the value corresponding to the key.\n///\n/// The key may be any borrowed form of the map's key type,\n/// but `Hash` and `Eq` on the borrowed form must match those for the key type.\npub fn get_mut<Q>(&mut self, key: &Q) -> Option<&mut V> {/* --snip-- */}\n\n/// Returns `true` if there is an entry corresponding to the key in the map.\npub fn contains_key<Q>(&self, key: &Q) -> bool {/* --snip-- */}\n\n/// Converts the OccupiedEntry into a mutable reference to the value in the entry\n/// with a lifetime bound to the map itself.\npub fn into_mut(self) -> &'a mut V {/* --snip-- */}\n\n/// Gets the given key's corresponding entry in the map for in-place manipulation.\npub fn entry(&mut self, key: K) -> Entry<K, V> {/* --snip-- */}\n")),(0,o.kt)("h2",{id:"initializing-a-hashmap"},"Initializing a HashMap"),(0,o.kt)("p",null,"Not initializing storage before you use it is a common error that can break your smart contract. For each key in a storage value, the value needs to be set before you can use it. To do this, we will create a private function which handles when the value is set and when it is not, and make sure we never work with uninitialized storage."),(0,o.kt)("p",null,"So given ",(0,o.kt)("inlineCode",{parentName:"p"},"my_number_map"),", imagine we wanted the default value for any given key to be ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),". We can build a function like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'\n#![cfg_attr(not(feature = "std"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod mycontract {\n\n    #[ink(storage)]\n    pub struct MyContract {\n        // Store a mapping from AccountIds to a u32\n        my_number_map: ink_storage::collections::HashMap<AccountId, u32>,\n    }\n\n    impl MyContract {\n        /// Public function.\n        /// Default constructor.\n        #[ink(constructor)]\n        pub fn default() -> Self {\n            Self {\n                my_number_map: Default::default(),\n            }\n        }\n    \n        /// Private function.\n        /// Returns the number for an AccountId or 0 if it is not set.\n        fn my_number_or_zero(&self, of: &AccountId) -> u32 {\n            let balance = self.my_number_map.get(of).unwrap_or(&0);\n            *balance\n        }\n    }\n}\n')),(0,o.kt)("p",null,"Here we see that after we ",(0,o.kt)("inlineCode",{parentName:"p"},"get")," the reference from ",(0,o.kt)("inlineCode",{parentName:"p"},"my_number_map")," we call ",(0,o.kt)("inlineCode",{parentName:"p"},"unwrap_or")," which will either ",(0,o.kt)("inlineCode",{parentName:"p"},"unwrap")," the reference, ",(0,o.kt)("em",{parentName:"p"},"or")," if there is no value, return some known reference. Then, when building functions that interact with this HashMap, you need to always remember to call this function rather than getting the value directly from storage."),(0,o.kt)("p",null,"Here is an example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'\n#![cfg_attr(not(feature = "std"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod mycontract {\n\n    #[ink(storage)]\n    pub struct MyContract {\n        // Store a mapping from AccountIds to a u32\n        my_number_map: ink_storage::collections::HashMap<AccountId, u32>,\n    }\n\n    impl MyContract {\n        // Get the value for a given AccountId\n        #[ink(message)]\n        pub fn get(&self, of: AccountId) -> u32 {\n            self.my_number_or_zero(&of)\n        }\n\n        // Get the value for the calling AccountId\n        #[ink(message)]\n        pub fn get_my_number(&self) -> u32 {\n            let caller = self.env().caller();\n            self.my_number_or_zero(&caller)\n        }\n\n        // Returns the number for an AccountId or 0 if it is not set.\n        fn my_number_or_zero(&self, of: &AccountId) -> u32 {\n            let value = self.my_number_map.get(of).unwrap_or(&0);\n            *value\n        }\n    }\n}\n')),(0,o.kt)("h2",{id:"contract-caller"},"Contract Caller"),(0,o.kt)("p",null,"As you might have noticed in the example above, we use a special function called ",(0,o.kt)("inlineCode",{parentName:"p"},"self.env().caller()"),". This function is available throughout the contract logic and will always return to you the contract caller."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"NOTE:")," The contract caller is not the same as the origin caller. If a user triggers a contract which then calls a subsequent contract, the ",(0,o.kt)("inlineCode",{parentName:"p"},"self.env().caller()")," in the second contract will be the address of the first contract, not the original user.")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"self.env().caller()"),' can be used in a number of different ways. In the example above, we are basically creating an "access control" layer which only allows users to access their own values. You can also save the contract owner during contract deployment for future references:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'\n#![cfg_attr(not(feature = "std"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod mycontract {\n\n    #[ink(storage)]\n    pub struct MyContract {\n        // Store a contract owner\n        owner: AccountId,\n    }\n\n    impl MyContract {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self {\n                owner: Self::env().caller();\n            }\n        }\n        /* --snip-- */\n    }\n}\n')),(0,o.kt)("p",null,"Then you can write permissioned functions which checks that the current caller is the owner of the contract."),(0,o.kt)("h2",{id:"modifying-a-hashmap"},"Modifying a HashMap"),(0,o.kt)("p",null,"Making changes to the value of a HashMap is just as sensitive as getting the value. If you try to modify some value before it has been initialized, your contract will panic!"),(0,o.kt)("p",null,"But have no fear, we can continue to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"my_number_or_zero")," function we created to protect us from these situations!"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"impl MyContract {\n\n    /* --snip-- */\n\n    /// Set the value for the calling AccountId\n    #[ink(message)]\n    pub fn set_my_number(&mut self, value: u32) {\n        let caller = self.env().caller();\n        self.my_number_map.insert(caller, value);\n    }\n\n    /// Add a value to the existing value for the calling AccountId\n    #[ink(message)]\n    pub fn add_my_number(&mut self, value: u32) {\n        let caller = self.env().caller();\n        let my_number = self.my_number_or_zero(&caller);\n        self.my_number_map.insert(caller, my_number + value);\n    }\n\n    /// Returns the number for an AccountId or 0 if it is not set.\n    fn my_number_or_zero(&self, of: &AccountId) -> u32 {\n        *self.my_number_map.get(of).unwrap_or(&0)\n    }\n}\n")),(0,o.kt)("p",null,"Here we have written two kinds of functions which modify a HashMap. One simply inserts the value\ndirectly into storage, with no need to read the value first, and another one modifies the existing\nvalue. Note how we can always ",(0,o.kt)("inlineCode",{parentName:"p"},"insert")," the value without worry, as that initialized the value in\nstorage, but before you can get or modify anything, we need to call ",(0,o.kt)("inlineCode",{parentName:"p"},"my_number_or_zero")," to make\nsure we are working with a real value."),(0,o.kt)("h2",{id:"entry-api"},"Entry API"),(0,o.kt)("p",null,"We will not always have an existing value on our contract's storage.\nWe can take advantage of the Rust ",(0,o.kt)("inlineCode",{parentName:"p"},"Option<T>")," type to help us.\nIf there's no value on the contract storage we will insert a new one; on\nthe contrary if there is an existing value we will only update it."),(0,o.kt)("p",null,"ink! HashMaps expose the well-known\n",(0,o.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/beta/std/collections/hash_map/enum.Entry.html"},(0,o.kt)("strong",{parentName:"a"},"HashMap Entry API")),'\nthat we can use to achieve this type of "upsert" behavior:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"let caller = self.env().caller();\nself.my_number_map\n    .entry(caller)\n    .and_modify(|old_value| *old_value += by)\n    .or_insert(by);\n")))}m.isMDXComponent=!0}}]);